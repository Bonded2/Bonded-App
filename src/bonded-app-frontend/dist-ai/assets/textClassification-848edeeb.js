var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});import{_ as __vitePreload}from"./icp-sdk-b71c0736.js";import{o as openDB}from"./vendor-e6e658b6.js";let transformers;const TRANSFORMERS_JSDELIVR_ESM_URL="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0/+esm",TRANSFORMERS_SKYPACK_URL="https://cdn.skypack.dev/@xenova/transformers@2.6.0",TRANSFORMERS_UNPKG_ESM_URL="https://unpkg.com/@xenova/transformers@2.6.0/dist/transformers.esm.js",_TextClassificationService=class _TextClassificationService{constructor(){this.model=null,this.tokenizer=null,this.isLoading=!1,this.isInitialized=!1,this.lastError=null,this.db=null,this.isProduction=typeof window<"u"&&(window.location.hostname.includes("icp0.io")||window.location.hostname.includes("ic0.app")),this.thresholds={explicit:.7,suggestive:.6,safe:.4},this.explicitKeywords=["sex","fuck","fucking","pussy","dick","cock","cum","orgasm","masturbate","blowjob","handjob","anal","oral","penetration","intercourse","climax","penis","vagina","breasts","nipples","genitals","anus","clitoris","horny","sexy","nude","naked","nudes","nsfw","xxx","porn","erotic","seduce","tease","aroused","turned on","make love","sleep together"],this.stats={textsProcessed:0,textsBlocked:0,avgProcessingTime:0,modelStatus:"unloaded"},this.initDB()}async initDB(){try{this.db=await openDB("BondedTextClassificationDB",1,{upgrade(db){db.objectStoreNames.contains("modelCache")||db.createObjectStore("modelCache"),db.objectStoreNames.contains("classificationCache")||db.createObjectStore("classificationCache").createIndex("timestamp","timestamp")}})}catch{}}async initialize(){if(this.isInitialized)return!0;if(this.isLoading){for(;this.isLoading;)await new Promise(resolve=>setTimeout(resolve,100));return this.isInitialized}this.isLoading=!0,this.stats.modelStatus="loading";try{const transformersLib=await this.loadTransformersJS();if(!transformersLib)throw new Error("Failed to load Transformers.js library");const transformersAPI=transformersLib.default||transformersLib,{pipeline}=transformersAPI;return this.model=await pipeline("text-classification","distilbert-base-uncased-finetuned-sst-2-english",{revision:"main",model_file_name:"model.onnx",quantized:!0}),this.isInitialized=!0,this.stats.modelStatus="loaded",this.db&&await this.db.put("modelCache",{initialized:!0,timestamp:Date.now(),model:"distilbert-base-uncased"},"initStatus"),!0}catch(error){return this.lastError=error,this.stats.modelStatus="failed",this.isInitialized=!0,!1}finally{this.isLoading=!1}}async loadTransformersJS(){if(transformers)return transformers;try{if(this.isProduction){const esmUrls=[TRANSFORMERS_JSDELIVR_ESM_URL,TRANSFORMERS_SKYPACK_URL,TRANSFORMERS_UNPKG_ESM_URL];for(const url of esmUrls)try{transformers=await __vitePreload(()=>import(url),[]);break}catch(urlError){if(console.warn(`❌ Failed to load from ${url}:`,urlError.message),url===esmUrls[esmUrls.length-1])throw urlError}}else transformers=await __vitePreload(()=>import("@xenova/transformers"),[])}catch(error){console.warn("⚠️ Failed to load Transformers.js:",error.message),transformers=null}return transformers}async isExplicitText(text){this.isInitialized||await this.initialize();const startTime=performance.now();try{if(!text||typeof text!="string")throw new Error("Invalid text input");const cleanText=text.trim().toLowerCase();if(cleanText.length===0)return this.getSafeResult("Empty text",performance.now()-startTime);const cachedResult=await this.getCachedResult(cleanText);if(cachedResult)return cachedResult;let result;return this.model?result=await this.classifyWithDistilBERT(cleanText):result=await this.classifyWithKeywords(cleanText),result.processing_time=performance.now()-startTime,this.updateStats(result.isExplicit,result.processing_time),await this.cacheResult(cleanText,result),result}catch(error){const fallbackResult=this.getFallbackResult(error.message);return fallbackResult.processing_time=performance.now()-startTime,fallbackResult}}async classifyWithDistilBERT(text){try{const results=await this.model(text),negativeScore=results.find(r=>r.label==="NEGATIVE")?.score||0,positiveScore=results.find(r=>r.label==="POSITIVE")?.score||0,keywordResult=await this.classifyWithKeywords(text);let isExplicit=!1,confidence=0,reasoning="";return keywordResult.isExplicit?(isExplicit=!0,confidence=Math.max(keywordResult.confidence,negativeScore),reasoning=`Explicit keywords detected: ${keywordResult.reasoning}`):negativeScore>this.thresholds.explicit?(isExplicit=!0,confidence=negativeScore,reasoning=`Negative sentiment detected (${Math.round(negativeScore*100)}%)`):(isExplicit=!1,confidence=positiveScore,reasoning=`Safe content (${Math.round(positiveScore*100)}% positive sentiment)`),{isExplicit,confidence:Math.round(confidence*100)/100,reasoning,method:"DistilBERT + Keywords",details:{sentiment:{positive:positiveScore,negative:negativeScore},keywords:keywordResult.details}}}catch{return await this.classifyWithKeywords(text)}}async classifyWithKeywords(text){const cleanText=text.toLowerCase(),words=cleanText.split(/\s+/);let explicitMatches=0,matchedKeywords=[];for(const keyword of this.explicitKeywords)cleanText.includes(keyword.toLowerCase())&&(explicitMatches++,matchedKeywords.push(keyword));const explicitPatterns=[/\b(want|need)\s+(you|to)\s+(fuck|sex|cum)\b/i,/\b(make|making)\s+love\b/i,/\b(turn|turned)\s+(me|you)\s+on\b/i,/\b(horny|aroused|wet)\b/i,/\b(nude|naked)\s+(pic|photo|image|selfie)s?\b/i];for(const pattern of explicitPatterns)pattern.test(text)&&(explicitMatches+=2,matchedKeywords.push(`pattern: ${pattern.source}`));const totalWords=words.length,explicitRatio=explicitMatches/Math.max(totalWords,1),isExplicit=explicitMatches>0&&(explicitRatio>.1||explicitMatches>=2),confidence=Math.min(explicitRatio*2+explicitMatches*.3,1);return{isExplicit,confidence:Math.round(confidence*100)/100,reasoning:isExplicit?`Contains explicit keywords: ${matchedKeywords.slice(0,3).join(", ")}`:"No explicit content detected",details:{method:"keyword-matching",explicitMatches,matchedKeywords:matchedKeywords.slice(0,5),totalWords,explicitRatio:Math.round(explicitRatio*100)/100},fallback:!0}}getSafeResult(reason,processingTime){return{isExplicit:!1,confidence:.9,reasoning:reason,details:{method:"validation",safe:!0},processing_time:processingTime,timestamp:Date.now()}}getFallbackResult(reason){return{isExplicit:!1,confidence:.3,reasoning:`Classification failed: ${reason}`,details:{method:"fallback",error:reason},fallback:!0,timestamp:Date.now()}}async cacheResult(text,result){if(this.db)try{const hash=this.simpleHash(text);await this.db.put("classificationCache",{hash,text:text.substring(0,100),result,timestamp:Date.now()},hash);const store=this.db.transaction("classificationCache","readwrite").objectStore("classificationCache"),allResults=await store.index("timestamp").getAll();if(allResults.length>500){allResults.sort((a,b)=>a.timestamp-b.timestamp);for(let i=0;i<allResults.length-500;i++)await store.delete(allResults[i].hash)}}catch{}}async getCachedResult(text){if(!this.db)return null;try{const hash=this.simpleHash(text),cached=await this.db.get("classificationCache",hash);return cached&&Date.now()-cached.timestamp<24*60*60*1e3?cached.result:null}catch{return null}}simpleHash(text){let hash=0;for(let i=0;i<text.length;i++){const char=text.charCodeAt(i);hash=(hash<<5)-hash+char,hash=hash&hash}return hash.toString(36)}async filterMessages(messages){try{const filteredMessages=[];for(const message of messages){const classification=await this.isExplicitText(message.text||"");classification.isExplicit||filteredMessages.push({...message,classification})}return filteredMessages}catch{return messages}}async classifyBatch(texts){const results=[];for(const text of texts){const result=await this.isExplicitText(text);results.push(result)}return results}updateThresholds(newThresholds){this.thresholds={...this.thresholds,...newThresholds}}addExplicitKeywords(keywords){const newKeywords=Array.isArray(keywords)?keywords:[keywords];this.explicitKeywords.push(...newKeywords.map(k=>k.toLowerCase())),this.explicitKeywords=[...new Set(this.explicitKeywords)]}updateStats(wasBlocked,processingTime){this.stats.textsProcessed++,wasBlocked&&this.stats.textsBlocked++,this.stats.avgProcessingTime=(this.stats.avgProcessingTime*.9+processingTime)/this.stats.textsProcessed}getStatus(){return{isInitialized:this.isInitialized,isLoading:this.isLoading,lastError:this.lastError?.message,modelStatus:this.stats.modelStatus,stats:{textsProcessed:this.stats.textsProcessed,textsBlocked:this.stats.textsBlocked,blockRate:this.stats.textsProcessed>0?this.stats.textsBlocked/this.stats.textsProcessed:0,avgProcessingTime:this.stats.avgProcessingTime},thresholds:this.thresholds,keywordCount:this.explicitKeywords.length}}async cleanup(){try{this.model&&(this.model=null),this.db&&(this.db.close(),this.db=null),this.isInitialized=!1,this.stats.modelStatus="unloaded"}catch{}}};__name(_TextClassificationService,"TextClassificationService");let TextClassificationService=_TextClassificationService;const textClassificationService=new TextClassificationService;export{textClassificationService};
