var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});import{s as sha224$1,a as sha256,b as borc,c as src,d as bls12_381,e as ed25519,f as buffer,o as openDB}from"./vendor-e6e658b6.js";const scriptRel="modulepreload",assetsURL=__name(function(dep){return"/"+dep},"assetsURL"),seen={},__vitePreload=__name(function(baseModule,deps,importerUrl){if(!deps||deps.length===0)return baseModule();const links=document.getElementsByTagName("link");return Promise.all(deps.map(dep=>{if(dep=assetsURL(dep),dep in seen)return;seen[dep]=!0;const isCss=dep.endsWith(".css"),cssSelector=isCss?'[rel="stylesheet"]':"";if(!!importerUrl)for(let i=links.length-1;i>=0;i--){const link2=links[i];if(link2.href===dep&&(!isCss||link2.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${dep}"]${cssSelector}`))return;const link=document.createElement("link");if(link.rel=isCss?"stylesheet":scriptRel,isCss||(link.as="script",link.crossOrigin=""),link.href=dep,document.head.appendChild(link),isCss)return new Promise((res,rej)=>{link.addEventListener("load",res),link.addEventListener("error",()=>rej(new Error(`Unable to preload CSS for ${dep}`)))})})).then(()=>baseModule()).catch(err=>{const e=new Event("vite:preloadError",{cancelable:!0});if(e.payload=err,window.dispatchEvent(e),!e.defaultPrevented)throw err})},"preload");var ReplicaRejectCode;(function(ReplicaRejectCode2){ReplicaRejectCode2[ReplicaRejectCode2.SysFatal=1]="SysFatal",ReplicaRejectCode2[ReplicaRejectCode2.SysTransient=2]="SysTransient",ReplicaRejectCode2[ReplicaRejectCode2.DestinationInvalid=3]="DestinationInvalid",ReplicaRejectCode2[ReplicaRejectCode2.CanisterReject=4]="CanisterReject",ReplicaRejectCode2[ReplicaRejectCode2.CanisterError=5]="CanisterError"})(ReplicaRejectCode||(ReplicaRejectCode={}));const alphabet="abcdefghijklmnopqrstuvwxyz234567",lookupTable=Object.create(null);for(let i=0;i<alphabet.length;i++)lookupTable[alphabet[i]]=i;lookupTable[0]=lookupTable.o;lookupTable[1]=lookupTable.i;function encode$2(input){let skip=0,bits=0,output="";function encodeByte(byte){return skip<0?bits|=byte>>-skip:bits=byte<<skip&248,skip>3?(skip-=8,1):(skip<4&&(output+=alphabet[bits>>3],skip+=5),0)}__name(encodeByte,"encodeByte");for(let i=0;i<input.length;)i+=encodeByte(input[i]);return output+(skip<0?alphabet[bits>>3]:"")}__name(encode$2,"encode$2");function decode$2(input){let skip=0,byte=0;const output=new Uint8Array(input.length*4/3|0);let o=0;function decodeChar(char){let val=lookupTable[char.toLowerCase()];if(val===void 0)throw new Error(`Invalid character: ${JSON.stringify(char)}`);val<<=3,byte|=val>>>skip,skip+=5,skip>=8&&(output[o++]=byte,skip-=8,skip>0?byte=val<<5-skip&255:byte=0)}__name(decodeChar,"decodeChar");for(const c of input)decodeChar(c);return output.slice(0,o)}__name(decode$2,"decode$2");const lookUpTable=new Uint32Array([0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117]);function getCrc32(buf){const b=new Uint8Array(buf);let crc=-1;for(let i=0;i<b.length;i++){const t=(b[i]^crc)&255;crc=lookUpTable[t]^crc>>>8}return(crc^-1)>>>0}__name(getCrc32,"getCrc32");function sha224(data){return sha224$1.create().update(new Uint8Array(data)).digest()}__name(sha224,"sha224");const JSON_KEY_PRINCIPAL="__principal__",SELF_AUTHENTICATING_SUFFIX=2,ANONYMOUS_SUFFIX=4,MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR="aaaaa-aa",fromHexString=__name(hexString=>{var _a4;return new Uint8Array(((_a4=hexString.match(/.{1,2}/g))!==null&&_a4!==void 0?_a4:[]).map(byte=>parseInt(byte,16)))},"fromHexString"),toHexString=__name(bytes=>bytes.reduce((str,byte)=>str+byte.toString(16).padStart(2,"0"),""),"toHexString");var _a;let Principal$1=(_a=class{constructor(_arr){this._arr=_arr,this._isPrincipal=!0}static anonymous(){return new this(new Uint8Array([ANONYMOUS_SUFFIX]))}static managementCanister(){return this.fromText(MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR)}static selfAuthenticating(publicKey){const sha=sha224(publicKey);return new this(new Uint8Array([...sha,SELF_AUTHENTICATING_SUFFIX]))}static from(other){if(typeof other=="string")return _a.fromText(other);if(Object.getPrototypeOf(other)===Uint8Array.prototype)return new _a(other);if(typeof other=="object"&&other!==null&&other._isPrincipal===!0)return new _a(other._arr);throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`)}static fromHex(hex){return new this(fromHexString(hex))}static fromText(text){let maybePrincipal=text;if(text.includes(JSON_KEY_PRINCIPAL)){const obj=JSON.parse(text);JSON_KEY_PRINCIPAL in obj&&(maybePrincipal=obj[JSON_KEY_PRINCIPAL])}const canisterIdNoDash=maybePrincipal.toLowerCase().replace(/-/g,"");let arr=decode$2(canisterIdNoDash);arr=arr.slice(4,arr.length);const principal=new this(arr);if(principal.toText()!==maybePrincipal)throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${maybePrincipal}" may not be a valid Principal ID).`);return principal}static fromUint8Array(arr){return new this(arr)}isAnonymous(){return this._arr.byteLength===1&&this._arr[0]===ANONYMOUS_SUFFIX}toUint8Array(){return this._arr}toHex(){return toHexString(this._arr).toUpperCase()}toText(){const checksumArrayBuf=new ArrayBuffer(4);new DataView(checksumArrayBuf).setUint32(0,getCrc32(this._arr));const checksum=new Uint8Array(checksumArrayBuf),bytes=Uint8Array.from(this._arr),array=new Uint8Array([...checksum,...bytes]),matches=encode$2(array).match(/.{1,5}/g);if(!matches)throw new Error;return matches.join("-")}toString(){return this.toText()}toJSON(){return{[JSON_KEY_PRINCIPAL]:this.toText()}}compareTo(other){for(let i=0;i<Math.min(this._arr.length,other._arr.length);i++){if(this._arr[i]<other._arr[i])return"lt";if(this._arr[i]>other._arr[i])return"gt"}return this._arr.length<other._arr.length?"lt":this._arr.length>other._arr.length?"gt":"eq"}ltEq(other){const cmp=this.compareTo(other);return cmp=="lt"||cmp=="eq"}gtEq(other){const cmp=this.compareTo(other);return cmp=="gt"||cmp=="eq"}},__name(_a,"Principal"),_a);function concat$1(...buffers){const result=new Uint8Array(buffers.reduce((acc,curr)=>acc+curr.byteLength,0));let index2=0;for(const b of buffers)result.set(new Uint8Array(b),index2),index2+=b.byteLength;return result.buffer}__name(concat$1,"concat$1");function toHex(buffer2){return[...new Uint8Array(buffer2)].map(x=>x.toString(16).padStart(2,"0")).join("")}__name(toHex,"toHex");const hexRe=new RegExp(/^[0-9a-fA-F]+$/);function fromHex(hex){if(!hexRe.test(hex))throw new Error("Invalid hexadecimal string.");const buffer2=[...hex].reduce((acc,curr,i)=>(acc[i/2|0]=(acc[i/2|0]||"")+curr,acc),[]).map(x=>Number.parseInt(x,16));return new Uint8Array(buffer2).buffer}__name(fromHex,"fromHex");function compare(b1,b2){if(b1.byteLength!==b2.byteLength)return b1.byteLength-b2.byteLength;const u1=new Uint8Array(b1),u2=new Uint8Array(b2);for(let i=0;i<u1.length;i++)if(u1[i]!==u2[i])return u1[i]-u2[i];return 0}__name(compare,"compare");function bufEquals(b1,b2){return compare(b1,b2)===0}__name(bufEquals,"bufEquals");function uint8ToBuf$1(arr){return new DataView(arr.buffer,arr.byteOffset,arr.byteLength).buffer}__name(uint8ToBuf$1,"uint8ToBuf$1");function bufFromBufLike$1(bufLike){return bufLike instanceof Uint8Array?uint8ToBuf$1(bufLike):bufLike instanceof ArrayBuffer?bufLike:Array.isArray(bufLike)?uint8ToBuf$1(new Uint8Array(bufLike)):"buffer"in bufLike?bufFromBufLike$1(bufLike.buffer):uint8ToBuf$1(new Uint8Array(bufLike))}__name(bufFromBufLike$1,"bufFromBufLike$1");const _AgentError=class _AgentError extends Error{constructor(message){super(message),this.message=message,this.name="AgentError",this.__proto__=_AgentError.prototype,Object.setPrototypeOf(this,_AgentError.prototype)}};__name(_AgentError,"AgentError");let AgentError=_AgentError;function concat(...buffers){const result=new Uint8Array(buffers.reduce((acc,curr)=>acc+curr.byteLength,0));let index2=0;for(const b of buffers)result.set(new Uint8Array(b),index2),index2+=b.byteLength;return result}__name(concat,"concat");const _PipeArrayBuffer=class _PipeArrayBuffer{constructor(buffer2,length=buffer2?.byteLength||0){this._buffer=bufFromBufLike(buffer2||new ArrayBuffer(0)),this._view=new Uint8Array(this._buffer,0,length)}save(){return this._view}restore(checkPoint){this._view=checkPoint}get buffer(){return bufFromBufLike(this._view.slice())}get byteLength(){return this._view.byteLength}read(num){const result=this._view.subarray(0,num);return this._view=this._view.subarray(num),result.slice().buffer}readUint8(){const result=this._view[0];return this._view=this._view.subarray(1),result}write(buf){const b=new Uint8Array(buf),offset=this._view.byteLength;this._view.byteOffset+this._view.byteLength+b.byteLength>=this._buffer.byteLength?this.alloc(b.byteLength):this._view=new Uint8Array(this._buffer,this._view.byteOffset,this._view.byteLength+b.byteLength),this._view.set(b,offset)}get end(){return this._view.byteLength===0}alloc(amount){const b=new ArrayBuffer((this._buffer.byteLength+amount)*1.2|0),v=new Uint8Array(b,0,this._view.byteLength+amount);v.set(this._view),this._buffer=b,this._view=v}};__name(_PipeArrayBuffer,"PipeArrayBuffer");let PipeArrayBuffer=_PipeArrayBuffer;function uint8ToBuf(arr){return new DataView(arr.buffer,arr.byteOffset,arr.byteLength).buffer}__name(uint8ToBuf,"uint8ToBuf");function bufFromBufLike(bufLike){return bufLike instanceof Uint8Array?uint8ToBuf(bufLike):bufLike instanceof ArrayBuffer?bufLike:Array.isArray(bufLike)?uint8ToBuf(new Uint8Array(bufLike)):"buffer"in bufLike?bufFromBufLike(bufLike.buffer):uint8ToBuf(new Uint8Array(bufLike))}__name(bufFromBufLike,"bufFromBufLike");function idlHash(s){const array=new TextEncoder().encode(s);let h=0;for(const c of array)h=(h*223+c)%2**32;return h}__name(idlHash,"idlHash");function idlLabelToId(label){if(/^_\d+_$/.test(label)||/^_0x[0-9a-fA-F]+_$/.test(label)){const num=+label.slice(1,-1);if(Number.isSafeInteger(num)&&num>=0&&num<2**32)return num}return idlHash(label)}__name(idlLabelToId,"idlLabelToId");function eob(){throw new Error("unexpected end of buffer")}__name(eob,"eob");function safeRead(pipe,num){return pipe.byteLength<num&&eob(),pipe.read(num)}__name(safeRead,"safeRead");function safeReadUint8(pipe){const byte=pipe.readUint8();return byte===void 0&&eob(),byte}__name(safeReadUint8,"safeReadUint8");function lebEncode(value){if(typeof value=="number"&&(value=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(value)),value<(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0))throw new Error("Cannot leb encode negative values.");const byteLength=(value===(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0)?0:Math.ceil(Math.log2(Number(value))))+1,pipe=new PipeArrayBuffer(new ArrayBuffer(byteLength),0);for(;;){const i=Number(value&(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(127));if(value/=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(128),value===(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0)){pipe.write(new Uint8Array([i]));break}else pipe.write(new Uint8Array([i|128]))}return pipe.buffer}__name(lebEncode,"lebEncode");function lebDecode(pipe){let weight=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(1),value=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0),byte;do byte=safeReadUint8(pipe),value+=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(byte&127).valueOf()*weight,weight*=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(128);while(byte>=128);return value}__name(lebDecode,"lebDecode");function slebEncode(value){typeof value=="number"&&(value=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(value));const isNeg=value<(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0);isNeg&&(value=-value-(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(1));const byteLength=(value===(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0)?0:Math.ceil(Math.log2(Number(value))))+1,pipe=new PipeArrayBuffer(new ArrayBuffer(byteLength),0);for(;;){const i=getLowerBytes(value);if(value/=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(128),isNeg&&value===(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0)&&i&64||!isNeg&&value===(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0)&&!(i&64)){pipe.write(new Uint8Array([i]));break}else pipe.write(new Uint8Array([i|128]))}function getLowerBytes(num){const bytes=num%(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(128);return Number(isNeg?(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(128)-bytes-(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(1):bytes)}return __name(getLowerBytes,"getLowerBytes"),pipe.buffer}__name(slebEncode,"slebEncode");function slebDecode(pipe){const pipeView=new Uint8Array(pipe.buffer);let len=0;for(;len<pipeView.byteLength;len++)if(pipeView[len]<128){if(!(pipeView[len]&64))return lebDecode(pipe);break}const bytes=new Uint8Array(safeRead(pipe,len+1));let value=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0);for(let i=bytes.byteLength-1;i>=0;i--)value=value*(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(128)+(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(128-(bytes[i]&127)-1);return-value-(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(1)}__name(slebDecode,"slebDecode");function writeUIntLE(value,byteLength){if((value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(value)<(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0))throw new Error("Cannot write negative values.");return writeIntLE(value,byteLength)}__name(writeUIntLE,"writeUIntLE");function writeIntLE(value,byteLength){value=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(value);const pipe=new PipeArrayBuffer(new ArrayBuffer(Math.min(1,byteLength)),0);let i=0,mul=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(256),sub=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0),byte=Number(value%mul);for(pipe.write(new Uint8Array([byte]));++i<byteLength;)value<0&&sub===(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(0)&&byte!==0&&(sub=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(1)),byte=Number((value/mul-sub)%(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(256)),pipe.write(new Uint8Array([byte])),mul*=(value2=>{try{return typeof value2=="string"?parseInt(value2,10)||0:Number(value2)||0}catch{return 0}})(256);return pipe.buffer}__name(writeIntLE,"writeIntLE");function readUIntLE(pipe,byteLength){let val=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(safeReadUint8(pipe)),mul=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1),i=0;for(;++i<byteLength;){mul*=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(256);const byte=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(safeReadUint8(pipe));val=val+mul*byte}return val}__name(readUIntLE,"readUIntLE");function readIntLE(pipe,byteLength){let val=readUIntLE(pipe,byteLength);const mul=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(2)**((value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(8)*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(byteLength-1)+(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(7));return val>=mul&&(val-=mul*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(2)),val}__name(readIntLE,"readIntLE");function iexp2(n){const nBig=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(n);if(n<0)throw new RangeError("Input must be non-negative");return(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1)<<nBig}__name(iexp2,"iexp2");const magicNumber="DIDL",toReadableString_max=400;function zipWith(xs,ys,f){return xs.map((x,i)=>f(x,ys[i]))}__name(zipWith,"zipWith");const _TypeTable=class _TypeTable{constructor(){this._typs=[],this._idx=new Map}has(obj){return this._idx.has(obj.name)}add(type,buf){const idx=this._typs.length;this._idx.set(type.name,idx),this._typs.push(buf)}merge(obj,knot){const idx=this._idx.get(obj.name),knotIdx=this._idx.get(knot);if(idx===void 0)throw new Error("Missing type index for "+obj);if(knotIdx===void 0)throw new Error("Missing type index for "+knot);this._typs[idx]=this._typs[knotIdx],this._typs.splice(knotIdx,1),this._idx.delete(knot)}encode(){const len=lebEncode(this._typs.length),buf=concat(...this._typs);return concat(len,buf)}indexOf(typeName){if(!this._idx.has(typeName))throw new Error("Missing type index for "+typeName);return slebEncode(this._idx.get(typeName)||0)}};__name(_TypeTable,"TypeTable");let TypeTable=_TypeTable;const _Visitor=class _Visitor{visitType(t,data){throw new Error("Not implemented")}visitPrimitive(t,data){return this.visitType(t,data)}visitEmpty(t,data){return this.visitPrimitive(t,data)}visitBool(t,data){return this.visitPrimitive(t,data)}visitNull(t,data){return this.visitPrimitive(t,data)}visitReserved(t,data){return this.visitPrimitive(t,data)}visitText(t,data){return this.visitPrimitive(t,data)}visitNumber(t,data){return this.visitPrimitive(t,data)}visitInt(t,data){return this.visitNumber(t,data)}visitNat(t,data){return this.visitNumber(t,data)}visitFloat(t,data){return this.visitPrimitive(t,data)}visitFixedInt(t,data){return this.visitNumber(t,data)}visitFixedNat(t,data){return this.visitNumber(t,data)}visitPrincipal(t,data){return this.visitPrimitive(t,data)}visitConstruct(t,data){return this.visitType(t,data)}visitVec(t,ty,data){return this.visitConstruct(t,data)}visitOpt(t,ty,data){return this.visitConstruct(t,data)}visitRecord(t,fields,data){return this.visitConstruct(t,data)}visitTuple(t,components,data){const fields=components.map((ty,i)=>[`_${i}_`,ty]);return this.visitRecord(t,fields,data)}visitVariant(t,fields,data){return this.visitConstruct(t,data)}visitRec(t,ty,data){return this.visitConstruct(ty,data)}visitFunc(t,data){return this.visitConstruct(t,data)}visitService(t,data){return this.visitConstruct(t,data)}};__name(_Visitor,"Visitor");let Visitor=_Visitor;const _Type=class _Type{display(){return this.name}valueToString(x){return toReadableString(x)}buildTypeTable(typeTable){typeTable.has(this)||this._buildTypeTableImpl(typeTable)}};__name(_Type,"Type");let Type=_Type;const _PrimitiveType=class _PrimitiveType extends Type{checkType(t){if(this.name!==t.name)throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);return t}_buildTypeTableImpl(typeTable){}};__name(_PrimitiveType,"PrimitiveType");let PrimitiveType=_PrimitiveType;const _ConstructType=class _ConstructType extends Type{checkType(t){if(t instanceof RecClass){const ty=t.getType();if(typeof ty>"u")throw new Error("type mismatch with uninitialized type");return ty}throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`)}encodeType(typeTable){return typeTable.indexOf(this.name)}};__name(_ConstructType,"ConstructType");let ConstructType=_ConstructType;const _EmptyClass=class _EmptyClass extends PrimitiveType{accept(v,d){return v.visitEmpty(this,d)}covariant(x){throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(){throw new Error("Empty cannot appear as a function argument")}valueToString(){throw new Error("Empty cannot appear as a value")}encodeType(){return slebEncode(-17)}decodeValue(){throw new Error("Empty cannot appear as an output")}get name(){return"empty"}};__name(_EmptyClass,"EmptyClass");let EmptyClass=_EmptyClass;const _UnknownClass=class _UnknownClass extends Type{checkType(t){throw new Error("Method not implemented for unknown.")}accept(v,d){throw v.visitType(this,d)}covariant(x){throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(){throw new Error("Unknown cannot appear as a function argument")}valueToString(){throw new Error("Unknown cannot appear as a value")}encodeType(){throw new Error("Unknown cannot be serialized")}decodeValue(b,t){let decodedValue=t.decodeValue(b,t);Object(decodedValue)!==decodedValue&&(decodedValue=Object(decodedValue));let typeFunc;return t instanceof RecClass?typeFunc=__name(()=>t.getType(),"typeFunc"):typeFunc=__name(()=>t,"typeFunc"),Object.defineProperty(decodedValue,"type",{value:typeFunc,writable:!0,enumerable:!1,configurable:!0}),decodedValue}_buildTypeTableImpl(){throw new Error("Unknown cannot be serialized")}get name(){return"Unknown"}};__name(_UnknownClass,"UnknownClass");let UnknownClass=_UnknownClass;const _BoolClass=class _BoolClass extends PrimitiveType{accept(v,d){return v.visitBool(this,d)}covariant(x){if(typeof x=="boolean")return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){return new Uint8Array([x?1:0])}encodeType(){return slebEncode(-2)}decodeValue(b,t){switch(this.checkType(t),safeReadUint8(b)){case 0:return!1;case 1:return!0;default:throw new Error("Boolean value out of range")}}get name(){return"bool"}};__name(_BoolClass,"BoolClass");let BoolClass=_BoolClass;const _NullClass=class _NullClass extends PrimitiveType{accept(v,d){return v.visitNull(this,d)}covariant(x){if(x===null)return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(){return new ArrayBuffer(0)}encodeType(){return slebEncode(-1)}decodeValue(b,t){return this.checkType(t),null}get name(){return"null"}};__name(_NullClass,"NullClass");let NullClass=_NullClass;const _ReservedClass=class _ReservedClass extends PrimitiveType{accept(v,d){return v.visitReserved(this,d)}covariant(x){return!0}encodeValue(){return new ArrayBuffer(0)}encodeType(){return slebEncode(-16)}decodeValue(b,t){return t.name!==this.name&&t.decodeValue(b,t),null}get name(){return"reserved"}};__name(_ReservedClass,"ReservedClass");let ReservedClass=_ReservedClass;const _TextClass=class _TextClass extends PrimitiveType{accept(v,d){return v.visitText(this,d)}covariant(x){if(typeof x=="string")return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){const buf=new TextEncoder().encode(x),len=lebEncode(buf.byteLength);return concat(len,buf)}encodeType(){return slebEncode(-15)}decodeValue(b,t){this.checkType(t);const len=lebDecode(b),buf=safeRead(b,Number(len));return new TextDecoder("utf8",{fatal:!0}).decode(buf)}get name(){return"text"}valueToString(x){return'"'+x+'"'}};__name(_TextClass,"TextClass");let TextClass=_TextClass;const _IntClass=class _IntClass extends PrimitiveType{accept(v,d){return v.visitInt(this,d)}covariant(x){if(typeof x=="number"||Number.isInteger(x))return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){return slebEncode(x)}encodeType(){return slebEncode(-4)}decodeValue(b,t){return this.checkType(t),slebDecode(b)}get name(){return"int"}valueToString(x){return x.toString()}};__name(_IntClass,"IntClass");let IntClass=_IntClass;const _NatClass=class _NatClass extends PrimitiveType{accept(v,d){return v.visitNat(this,d)}covariant(x){if(typeof x=="number"&&x>=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(0)||Number.isInteger(x)&&x>=0)return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){return lebEncode(x)}encodeType(){return slebEncode(-3)}decodeValue(b,t){return this.checkType(t),lebDecode(b)}get name(){return"nat"}valueToString(x){return x.toString()}};__name(_NatClass,"NatClass");let NatClass=_NatClass;const _FloatClass=class _FloatClass extends PrimitiveType{constructor(_bits){if(super(),this._bits=_bits,_bits!==32&&_bits!==64)throw new Error("not a valid float type")}accept(v,d){return v.visitFloat(this,d)}covariant(x){if(typeof x=="number"||x instanceof Number)return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){const buf=new ArrayBuffer(this._bits/8),view=new DataView(buf);return this._bits===32?view.setFloat32(0,x,!0):view.setFloat64(0,x,!0),buf}encodeType(){const opcode=this._bits===32?-13:-14;return slebEncode(opcode)}decodeValue(b,t){this.checkType(t);const bytes=safeRead(b,this._bits/8),view=new DataView(bytes);return this._bits===32?view.getFloat32(0,!0):view.getFloat64(0,!0)}get name(){return"float"+this._bits}valueToString(x){return x.toString()}};__name(_FloatClass,"FloatClass");let FloatClass=_FloatClass;const _FixedIntClass=class _FixedIntClass extends PrimitiveType{constructor(_bits){super(),this._bits=_bits}accept(v,d){return v.visitFixedInt(this,d)}covariant(x){const min=iexp2(this._bits-1)*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(-1),max=iexp2(this._bits-1)-(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1);let ok=!1;if(typeof x=="number")ok=x>=min&&x<=max;else if(Number.isInteger(x)){const v=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(x);ok=v>=min&&v<=max}else ok=!1;if(ok)return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){return writeIntLE(x,this._bits/8)}encodeType(){const offset=Math.log2(this._bits)-3;return slebEncode(-9-offset)}decodeValue(b,t){this.checkType(t);const num=readIntLE(b,this._bits/8);return this._bits<=32?Number(num):num}get name(){return`int${this._bits}`}valueToString(x){return x.toString()}};__name(_FixedIntClass,"FixedIntClass");let FixedIntClass=_FixedIntClass;const _FixedNatClass=class _FixedNatClass extends PrimitiveType{constructor(_bits){super(),this._bits=_bits}accept(v,d){return v.visitFixedNat(this,d)}covariant(x){const max=iexp2(this._bits);let ok=!1;if(typeof x=="number"&&x>=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(0)?ok=x<max:Number.isInteger(x)&&x>=0?ok=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(x)<max:ok=!1,ok)return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){return writeUIntLE(x,this._bits/8)}encodeType(){const offset=Math.log2(this._bits)-3;return slebEncode(-5-offset)}decodeValue(b,t){this.checkType(t);const num=readUIntLE(b,this._bits/8);return this._bits<=32?Number(num):num}get name(){return`nat${this._bits}`}valueToString(x){return x.toString()}};__name(_FixedNatClass,"FixedNatClass");let FixedNatClass=_FixedNatClass;const _VecClass=class _VecClass extends ConstructType{constructor(_type){super(),this._type=_type,this._blobOptimization=!1,_type instanceof FixedNatClass&&_type._bits===8&&(this._blobOptimization=!0)}accept(v,d){return v.visitVec(this,this._type,d)}covariant(x){const bits=this._type instanceof FixedNatClass?this._type._bits:this._type instanceof FixedIntClass?this._type._bits:0;if(ArrayBuffer.isView(x)&&bits==x.BYTES_PER_ELEMENT*8||Array.isArray(x)&&x.every((v,idx)=>{try{return this._type.covariant(v)}catch(e){throw new Error(`Invalid ${this.display()} argument: 

index ${idx} -> ${e.message}`)}}))return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){const len=lebEncode(x.length);if(this._blobOptimization)return concat(len,new Uint8Array(x));if(ArrayBuffer.isView(x))return concat(len,new Uint8Array(x.buffer));const buf=new PipeArrayBuffer(new ArrayBuffer(len.byteLength+x.length),0);buf.write(len);for(const d of x){const encoded=this._type.encodeValue(d);buf.write(new Uint8Array(encoded))}return buf.buffer}_buildTypeTableImpl(typeTable){this._type.buildTypeTable(typeTable);const opCode=slebEncode(-19),buffer2=this._type.encodeType(typeTable);typeTable.add(this,concat(opCode,buffer2))}decodeValue(b,t){const vec=this.checkType(t);if(!(vec instanceof _VecClass))throw new Error("Not a vector type");const len=Number(lebDecode(b));if(this._type instanceof FixedNatClass){if(this._type._bits==8)return new Uint8Array(b.read(len));if(this._type._bits==16)return new Uint16Array(b.read(len*2));if(this._type._bits==32)return new Uint32Array(b.read(len*4));if(this._type._bits==64)return new BigUint64Array(b.read(len*8))}if(this._type instanceof FixedIntClass){if(this._type._bits==8)return new Int8Array(b.read(len));if(this._type._bits==16)return new Int16Array(b.read(len*2));if(this._type._bits==32)return new Int32Array(b.read(len*4));if(this._type._bits==64)return new BigInt64Array(b.read(len*8))}const rets=[];for(let i=0;i<len;i++)rets.push(this._type.decodeValue(b,vec._type));return rets}get name(){return`vec ${this._type.name}`}display(){return`vec ${this._type.display()}`}valueToString(x){return"vec {"+x.map(e=>this._type.valueToString(e)).join("; ")+"}"}};__name(_VecClass,"VecClass");let VecClass=_VecClass;const _OptClass=class _OptClass extends ConstructType{constructor(_type){super(),this._type=_type}accept(v,d){return v.visitOpt(this,this._type,d)}covariant(x){try{if(Array.isArray(x)&&(x.length===0||x.length===1&&this._type.covariant(x[0])))return!0}catch(e){throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} 

-> ${e.message}`)}throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){return x.length===0?new Uint8Array([0]):concat(new Uint8Array([1]),this._type.encodeValue(x[0]))}_buildTypeTableImpl(typeTable){this._type.buildTypeTable(typeTable);const opCode=slebEncode(-18),buffer2=this._type.encodeType(typeTable);typeTable.add(this,concat(opCode,buffer2))}decodeValue(b,t){if(t instanceof NullClass)return[];if(t instanceof ReservedClass)return[];let wireType=t;if(t instanceof RecClass){const ty=t.getType();if(typeof ty>"u")throw new Error("type mismatch with uninitialized type");wireType=ty}if(wireType instanceof _OptClass)switch(safeReadUint8(b)){case 0:return[];case 1:{const checkpoint=b.save();try{return[this._type.decodeValue(b,wireType._type)]}catch{return b.restore(checkpoint),wireType._type.decodeValue(b,wireType._type),[]}}default:throw new Error("Not an option value")}else{if(this._type instanceof NullClass||this._type instanceof _OptClass||this._type instanceof ReservedClass)return wireType.decodeValue(b,wireType),[];{const checkpoint=b.save();try{return[this._type.decodeValue(b,t)]}catch{return b.restore(checkpoint),wireType.decodeValue(b,t),[]}}}}get name(){return`opt ${this._type.name}`}display(){return`opt ${this._type.display()}`}valueToString(x){return x.length===0?"null":`opt ${this._type.valueToString(x[0])}`}};__name(_OptClass,"OptClass");let OptClass=_OptClass;const _RecordClass=class _RecordClass extends ConstructType{constructor(fields={}){super(),this._fields=Object.entries(fields).sort((a,b)=>idlLabelToId(a[0])-idlLabelToId(b[0]))}accept(v,d){return v.visitRecord(this,this._fields,d)}tryAsTuple(){const res=[];for(let i=0;i<this._fields.length;i++){const[key,type]=this._fields[i];if(key!==`_${i}_`)return null;res.push(type)}return res}covariant(x){if(typeof x=="object"&&this._fields.every(([k,t])=>{if(!x.hasOwnProperty(k))throw new Error(`Record is missing key "${k}".`);try{return t.covariant(x[k])}catch(e){throw new Error(`Invalid ${this.display()} argument: 

field ${k} -> ${e.message}`)}}))return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){const values=this._fields.map(([key])=>x[key]),bufs=zipWith(this._fields,values,([,c],d)=>c.encodeValue(d));return concat(...bufs)}_buildTypeTableImpl(T){this._fields.forEach(([_,value])=>value.buildTypeTable(T));const opCode=slebEncode(-20),len=lebEncode(this._fields.length),fields=this._fields.map(([key,value])=>concat(lebEncode(idlLabelToId(key)),value.encodeType(T)));T.add(this,concat(opCode,len,concat(...fields)))}decodeValue(b,t){const record=this.checkType(t);if(!(record instanceof _RecordClass))throw new Error("Not a record type");const x={};let expectedRecordIdx=0,actualRecordIdx=0;for(;actualRecordIdx<record._fields.length;){const[hash2,type]=record._fields[actualRecordIdx];if(expectedRecordIdx>=this._fields.length){type.decodeValue(b,type),actualRecordIdx++;continue}const[expectKey,expectType]=this._fields[expectedRecordIdx],expectedId=idlLabelToId(this._fields[expectedRecordIdx][0]),actualId=idlLabelToId(hash2);if(expectedId===actualId)x[expectKey]=expectType.decodeValue(b,type),expectedRecordIdx++,actualRecordIdx++;else if(actualId>expectedId)if(expectType instanceof OptClass||expectType instanceof ReservedClass)x[expectKey]=[],expectedRecordIdx++;else throw new Error("Cannot find required field "+expectKey);else type.decodeValue(b,type),actualRecordIdx++}for(const[expectKey,expectType]of this._fields.slice(expectedRecordIdx))if(expectType instanceof OptClass||expectType instanceof ReservedClass)x[expectKey]=[];else throw new Error("Cannot find required field "+expectKey);return x}get name(){return`record {${this._fields.map(([key,value])=>key+":"+value.name).join("; ")}}`}display(){return`record {${this._fields.map(([key,value])=>key+":"+value.display()).join("; ")}}`}valueToString(x){const values=this._fields.map(([key])=>x[key]);return`record {${zipWith(this._fields,values,([k,c],d)=>k+"="+c.valueToString(d)).join("; ")}}`}};__name(_RecordClass,"RecordClass");let RecordClass=_RecordClass;const _TupleClass=class _TupleClass extends RecordClass{constructor(_components){const x={};_components.forEach((e,i)=>x["_"+i+"_"]=e),super(x),this._components=_components}accept(v,d){return v.visitTuple(this,this._components,d)}covariant(x){if(Array.isArray(x)&&x.length>=this._fields.length&&this._components.every((t,i)=>{try{return t.covariant(x[i])}catch(e){throw new Error(`Invalid ${this.display()} argument: 

index ${i} -> ${e.message}`)}}))return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){const bufs=zipWith(this._components,x,(c,d)=>c.encodeValue(d));return concat(...bufs)}decodeValue(b,t){const tuple=this.checkType(t);if(!(tuple instanceof _TupleClass))throw new Error("not a tuple type");if(tuple._components.length<this._components.length)throw new Error("tuple mismatch");const res=[];for(const[i,wireType]of tuple._components.entries())i>=this._components.length?wireType.decodeValue(b,wireType):res.push(this._components[i].decodeValue(b,wireType));return res}display(){return`record {${this._components.map(value=>value.display()).join("; ")}}`}valueToString(values){return`record {${zipWith(this._components,values,(c,d)=>c.valueToString(d)).join("; ")}}`}};__name(_TupleClass,"TupleClass");let TupleClass=_TupleClass;const _VariantClass=class _VariantClass extends ConstructType{constructor(fields={}){super(),this._fields=Object.entries(fields).sort((a,b)=>idlLabelToId(a[0])-idlLabelToId(b[0]))}accept(v,d){return v.visitVariant(this,this._fields,d)}covariant(x){if(typeof x=="object"&&Object.entries(x).length===1&&this._fields.every(([k,v])=>{try{return!x.hasOwnProperty(k)||v.covariant(x[k])}catch(e){throw new Error(`Invalid ${this.display()} argument: 

variant ${k} -> ${e.message}`)}}))return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){for(let i=0;i<this._fields.length;i++){const[name,type]=this._fields[i];if(x.hasOwnProperty(name)){const idx=lebEncode(i),buf=type.encodeValue(x[name]);return concat(idx,buf)}}throw Error("Variant has no data: "+x)}_buildTypeTableImpl(typeTable){this._fields.forEach(([,type])=>{type.buildTypeTable(typeTable)});const opCode=slebEncode(-21),len=lebEncode(this._fields.length),fields=this._fields.map(([key,value])=>concat(lebEncode(idlLabelToId(key)),value.encodeType(typeTable)));typeTable.add(this,concat(opCode,len,...fields))}decodeValue(b,t){const variant=this.checkType(t);if(!(variant instanceof _VariantClass))throw new Error("Not a variant type");const idx=Number(lebDecode(b));if(idx>=variant._fields.length)throw Error("Invalid variant index: "+idx);const[wireHash,wireType]=variant._fields[idx];for(const[key,expectType]of this._fields)if(idlLabelToId(wireHash)===idlLabelToId(key)){const value=expectType.decodeValue(b,wireType);return{[key]:value}}throw new Error("Cannot find field hash "+wireHash)}get name(){return`variant {${this._fields.map(([key,type])=>key+":"+type.name).join("; ")}}`}display(){return`variant {${this._fields.map(([key,type])=>key+(type.name==="null"?"":`:${type.display()}`)).join("; ")}}`}valueToString(x){for(const[name,type]of this._fields)if(x.hasOwnProperty(name)){const value=type.valueToString(x[name]);return value==="null"?`variant {${name}}`:`variant {${name}=${value}}`}throw new Error("Variant has no data: "+x)}};__name(_VariantClass,"VariantClass");let VariantClass=_VariantClass;const _RecClass=class _RecClass extends ConstructType{constructor(){super(...arguments),this._id=_RecClass._counter++,this._type=void 0}accept(v,d){if(!this._type)throw Error("Recursive type uninitialized.");return v.visitRec(this,this._type,d)}fill(t){this._type=t}getType(){return this._type}covariant(x){if(this._type&&this._type.covariant(x))return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){if(!this._type)throw Error("Recursive type uninitialized.");return this._type.encodeValue(x)}_buildTypeTableImpl(typeTable){if(!this._type)throw Error("Recursive type uninitialized.");typeTable.add(this,new Uint8Array([])),this._type.buildTypeTable(typeTable),typeTable.merge(this,this._type.name)}decodeValue(b,t){if(!this._type)throw Error("Recursive type uninitialized.");return this._type.decodeValue(b,t)}get name(){return`rec_${this._id}`}display(){if(!this._type)throw Error("Recursive type uninitialized.");return`μ${this.name}.${this._type.name}`}valueToString(x){if(!this._type)throw Error("Recursive type uninitialized.");return this._type.valueToString(x)}};__name(_RecClass,"RecClass");let RecClass=_RecClass;RecClass._counter=0;function decodePrincipalId(b){if(safeReadUint8(b)!==1)throw new Error("Cannot decode principal");const len=Number(lebDecode(b));return Principal$1.fromUint8Array(new Uint8Array(safeRead(b,len)))}__name(decodePrincipalId,"decodePrincipalId");const _PrincipalClass=class _PrincipalClass extends PrimitiveType{accept(v,d){return v.visitPrincipal(this,d)}covariant(x){if(x&&x._isPrincipal)return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){const buf=x.toUint8Array(),len=lebEncode(buf.byteLength);return concat(new Uint8Array([1]),len,buf)}encodeType(){return slebEncode(-24)}decodeValue(b,t){return this.checkType(t),decodePrincipalId(b)}get name(){return"principal"}valueToString(x){return`${this.name} "${x.toText()}"`}};__name(_PrincipalClass,"PrincipalClass");let PrincipalClass=_PrincipalClass;const _FuncClass=class _FuncClass extends ConstructType{constructor(argTypes,retTypes,annotations=[]){super(),this.argTypes=argTypes,this.retTypes=retTypes,this.annotations=annotations}static argsToString(types,v){if(types.length!==v.length)throw new Error("arity mismatch");return"("+types.map((t,i)=>t.valueToString(v[i])).join(", ")+")"}accept(v,d){return v.visitFunc(this,d)}covariant(x){if(Array.isArray(x)&&x.length===2&&x[0]&&x[0]._isPrincipal&&typeof x[1]=="string")return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue([principal,methodName]){const buf=principal.toUint8Array(),len=lebEncode(buf.byteLength),canister=concat(new Uint8Array([1]),len,buf),method=new TextEncoder().encode(methodName),methodLen=lebEncode(method.byteLength);return concat(new Uint8Array([1]),canister,methodLen,method)}_buildTypeTableImpl(T){this.argTypes.forEach(arg=>arg.buildTypeTable(T)),this.retTypes.forEach(arg=>arg.buildTypeTable(T));const opCode=slebEncode(-22),argLen=lebEncode(this.argTypes.length),args=concat(...this.argTypes.map(arg=>arg.encodeType(T))),retLen=lebEncode(this.retTypes.length),rets=concat(...this.retTypes.map(arg=>arg.encodeType(T))),annLen=lebEncode(this.annotations.length),anns=concat(...this.annotations.map(a=>this.encodeAnnotation(a)));T.add(this,concat(opCode,argLen,args,retLen,rets,annLen,anns))}decodeValue(b){if(safeReadUint8(b)!==1)throw new Error("Cannot decode function reference");const canister=decodePrincipalId(b),mLen=Number(lebDecode(b)),buf=safeRead(b,mLen),method=new TextDecoder("utf8",{fatal:!0}).decode(buf);return[canister,method]}get name(){const args=this.argTypes.map(arg=>arg.name).join(", "),rets=this.retTypes.map(arg=>arg.name).join(", "),annon=" "+this.annotations.join(" ");return`(${args}) -> (${rets})${annon}`}valueToString([principal,str]){return`func "${principal.toText()}".${str}`}display(){const args=this.argTypes.map(arg=>arg.display()).join(", "),rets=this.retTypes.map(arg=>arg.display()).join(", "),annon=" "+this.annotations.join(" ");return`(${args}) → (${rets})${annon}`}encodeAnnotation(ann){if(ann==="query")return new Uint8Array([1]);if(ann==="oneway")return new Uint8Array([2]);if(ann==="composite_query")return new Uint8Array([3]);throw new Error("Illegal function annotation")}};__name(_FuncClass,"FuncClass");let FuncClass=_FuncClass;const _ServiceClass=class _ServiceClass extends ConstructType{constructor(fields){super(),this._fields=Object.entries(fields).sort((a,b)=>a[0]<b[0]?-1:a[0]>b[0]?1:0)}accept(v,d){return v.visitService(this,d)}covariant(x){if(x&&x._isPrincipal)return!0;throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`)}encodeValue(x){const buf=x.toUint8Array(),len=lebEncode(buf.length);return concat(new Uint8Array([1]),len,buf)}_buildTypeTableImpl(T){this._fields.forEach(([_,func])=>func.buildTypeTable(T));const opCode=slebEncode(-23),len=lebEncode(this._fields.length),meths=this._fields.map(([label,func])=>{const labelBuf=new TextEncoder().encode(label),labelLen=lebEncode(labelBuf.length);return concat(labelLen,labelBuf,func.encodeType(T))});T.add(this,concat(opCode,len,...meths))}decodeValue(b){return decodePrincipalId(b)}get name(){return`service {${this._fields.map(([key,value])=>key+":"+value.name).join("; ")}}`}valueToString(x){return`service "${x.toText()}"`}};__name(_ServiceClass,"ServiceClass");let ServiceClass=_ServiceClass;function toReadableString(x){const str=JSON.stringify(x,(_key,value)=>typeof value=="number"?`((value) => { try { return typeof value === "string" ? parseInt(value, 10) || 0 : Number(value) || 0; } catch(e) { return 0; } })(${value})`:value);return str&&str.length>toReadableString_max?str.substring(0,toReadableString_max-3)+"...":str}__name(toReadableString,"toReadableString");function encode$1(argTypes,args){if(args.length<argTypes.length)throw Error("Wrong number of message arguments");const typeTable=new TypeTable;argTypes.forEach(t=>t.buildTypeTable(typeTable));const magic=new TextEncoder().encode(magicNumber),table=typeTable.encode(),len=lebEncode(args.length),typs=concat(...argTypes.map(t=>t.encodeType(typeTable))),vals=concat(...zipWith(argTypes,args,(t,x)=>{try{t.covariant(x)}catch(e){throw new Error(e.message+`

`)}return t.encodeValue(x)}));return concat(magic,table,len,typs,vals)}__name(encode$1,"encode$1");function decode$1(retTypes,bytes){const b=new PipeArrayBuffer(bytes);if(bytes.byteLength<magicNumber.length)throw new Error("Message length smaller than magic number");const magicBuffer=safeRead(b,magicNumber.length),magic=new TextDecoder().decode(magicBuffer);if(magic!==magicNumber)throw new Error("Wrong magic number: "+JSON.stringify(magic));function readTypeTable(pipe){const typeTable=[],len=Number(lebDecode(pipe));for(let i=0;i<len;i++){const ty=Number(slebDecode(pipe));switch(ty){case-18:case-19:{const t=Number(slebDecode(pipe));typeTable.push([ty,t]);break}case-20:case-21:{const fields=[];let objectLength=Number(lebDecode(pipe)),prevHash;for(;objectLength--;){const hash2=Number(lebDecode(pipe));if(hash2>=Math.pow(2,32))throw new Error("field id out of 32-bit range");if(typeof prevHash=="number"&&prevHash>=hash2)throw new Error("field id collision or not sorted");prevHash=hash2;const t=Number(slebDecode(pipe));fields.push([hash2,t])}typeTable.push([ty,fields]);break}case-22:{const args=[];let argLength=Number(lebDecode(pipe));for(;argLength--;)args.push(Number(slebDecode(pipe)));const returnValues=[];let returnValuesLength=Number(lebDecode(pipe));for(;returnValuesLength--;)returnValues.push(Number(slebDecode(pipe)));const annotations=[];let annotationLength=Number(lebDecode(pipe));for(;annotationLength--;)switch(Number(lebDecode(pipe))){case 1:{annotations.push("query");break}case 2:{annotations.push("oneway");break}case 3:{annotations.push("composite_query");break}default:throw new Error("unknown annotation")}typeTable.push([ty,[args,returnValues,annotations]]);break}case-23:{let servLength=Number(lebDecode(pipe));const methods=[];for(;servLength--;){const nameLength=Number(lebDecode(pipe)),funcName=new TextDecoder().decode(safeRead(pipe,nameLength)),funcType=slebDecode(pipe);methods.push([funcName,funcType])}typeTable.push([ty,methods]);break}default:throw new Error("Illegal op_code: "+ty)}}const rawList=[],length=Number(lebDecode(pipe));for(let i=0;i<length;i++)rawList.push(Number(slebDecode(pipe)));return[typeTable,rawList]}__name(readTypeTable,"readTypeTable");const[rawTable,rawTypes]=readTypeTable(b);if(rawTypes.length<retTypes.length)throw new Error("Wrong number of return values");const table=rawTable.map(_=>Rec());function getType(t){if(t<-24)throw new Error("future value not supported");if(t<0)switch(t){case-1:return Null;case-2:return Bool;case-3:return Nat;case-4:return Int;case-5:return Nat8;case-6:return Nat16;case-7:return Nat32;case-8:return Nat64;case-9:return Int8;case-10:return Int16;case-11:return Int32;case-12:return Int64;case-13:return Float32;case-14:return Float64;case-15:return Text;case-16:return Reserved;case-17:return Empty;case-24:return Principal;default:throw new Error("Illegal op_code: "+t)}if(t>=rawTable.length)throw new Error("type index out of range");return table[t]}__name(getType,"getType");function buildType(entry){switch(entry[0]){case-19:{const ty=getType(entry[1]);return Vec(ty)}case-18:{const ty=getType(entry[1]);return Opt(ty)}case-20:{const fields={};for(const[hash2,ty]of entry[1]){const name=`_${hash2}_`;fields[name]=getType(ty)}const record=Record(fields),tuple=record.tryAsTuple();return Array.isArray(tuple)?Tuple(...tuple):record}case-21:{const fields={};for(const[hash2,ty]of entry[1]){const name=`_${hash2}_`;fields[name]=getType(ty)}return Variant(fields)}case-22:{const[args,returnValues,annotations]=entry[1];return Func(args.map(t=>getType(t)),returnValues.map(t=>getType(t)),annotations)}case-23:{const rec={},methods=entry[1];for(const[name,typeRef]of methods){let type=getType(typeRef);if(type instanceof RecClass&&(type=type.getType()),!(type instanceof FuncClass))throw new Error("Illegal service definition: services can only contain functions");rec[name]=type}return Service(rec)}default:throw new Error("Illegal op_code: "+entry[0])}}__name(buildType,"buildType"),rawTable.forEach((entry,i)=>{if(entry[0]===-22){const t=buildType(entry);table[i].fill(t)}}),rawTable.forEach((entry,i)=>{if(entry[0]!==-22){const t=buildType(entry);table[i].fill(t)}});const types=rawTypes.map(t=>getType(t)),output=retTypes.map((t,i)=>t.decodeValue(b,types[i]));for(let ind=retTypes.length;ind<types.length;ind++)types[ind].decodeValue(b,types[ind]);if(b.byteLength>0)throw new Error("decode: Left-over bytes");return output}__name(decode$1,"decode$1");const Empty=new EmptyClass,Reserved=new ReservedClass,Unknown=new UnknownClass,Bool=new BoolClass,Null=new NullClass,Text=new TextClass,Int=new IntClass,Nat=new NatClass,Float32=new FloatClass(32),Float64=new FloatClass(64),Int8=new FixedIntClass(8),Int16=new FixedIntClass(16),Int32=new FixedIntClass(32),Int64=new FixedIntClass(64),Nat8=new FixedNatClass(8),Nat16=new FixedNatClass(16),Nat32=new FixedNatClass(32),Nat64=new FixedNatClass(64),Principal=new PrincipalClass;function Tuple(...types){return new TupleClass(types)}__name(Tuple,"Tuple");function Vec(t){return new VecClass(t)}__name(Vec,"Vec");function Opt(t){return new OptClass(t)}__name(Opt,"Opt");function Record(t){return new RecordClass(t)}__name(Record,"Record");function Variant(fields){return new VariantClass(fields)}__name(Variant,"Variant");function Rec(){return new RecClass}__name(Rec,"Rec");function Func(args,ret,annotations=[]){return new FuncClass(args,ret,annotations)}__name(Func,"Func");function Service(t){return new ServiceClass(t)}__name(Service,"Service");const IDL=Object.freeze(Object.defineProperty({__proto__:null,Bool,BoolClass,ConstructType,Empty,EmptyClass,FixedIntClass,FixedNatClass,Float32,Float64,FloatClass,Func,FuncClass,Int,Int16,Int32,Int64,Int8,IntClass,Nat,Nat16,Nat32,Nat64,Nat8,NatClass,Null,NullClass,Opt,OptClass,PrimitiveType,Principal,PrincipalClass,Rec,RecClass,Record,RecordClass,Reserved,ReservedClass,Service,ServiceClass,Text,TextClass,Tuple,TupleClass,Type,Unknown,UnknownClass,Variant,VariantClass,Vec,VecClass,Visitor,decode:decode$1,encode:encode$1},Symbol.toStringTag,{value:"Module"}));function hash(data){return uint8ToBuf$1(sha256.create().update(new Uint8Array(data)).digest())}__name(hash,"hash");function hashValue(value){if(value instanceof borc.Tagged)return hashValue(value.value);if(typeof value=="string")return hashString(value);if(typeof value=="number")return hash(lebEncode(value));if(value instanceof ArrayBuffer||ArrayBuffer.isView(value))return hash(value);if(Array.isArray(value)){const vals=value.map(hashValue);return hash(concat$1(...vals))}else{if(value&&typeof value=="object"&&value._isPrincipal)return hash(value.toUint8Array());if(typeof value=="object"&&value!==null&&typeof value.toHash=="function")return hashValue(value.toHash());if(typeof value=="object")return hashOfMap(value);if(typeof value=="number")return hash(lebEncode(value))}throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`),{value})}__name(hashValue,"hashValue");const hashString=__name(value=>{const encoded=new TextEncoder().encode(value);return hash(encoded)},"hashString");function requestIdOf(request2){return hashOfMap(request2)}__name(requestIdOf,"requestIdOf");function hashOfMap(map){const sorted=Object.entries(map).filter(([,value])=>value!==void 0).map(([key,value])=>{const hashedKey=hashString(key),hashedValue=hashValue(value);return[hashedKey,hashedValue]}).sort(([k1],[k2])=>compare(k1,k2)),concatenated=concat$1(...sorted.map(x=>concat$1(...x)));return hash(concatenated)}__name(hashOfMap,"hashOfMap");var __rest$1=globalThis&&globalThis.__rest||function(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]]);return t};const domainSeparator$1=new TextEncoder().encode(`
ic-request`),_SignIdentity=class _SignIdentity{getPrincipal(){return this._principal||(this._principal=Principal$1.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()))),this._principal}async transformRequest(request2){const{body}=request2,fields=__rest$1(request2,["body"]),requestId=requestIdOf(body);return Object.assign(Object.assign({},fields),{body:{content:body,sender_pubkey:this.getPublicKey().toDer(),sender_sig:await this.sign(concat$1(domainSeparator$1,requestId))}})}};__name(_SignIdentity,"SignIdentity");let SignIdentity=_SignIdentity;const _AnonymousIdentity=class _AnonymousIdentity{getPrincipal(){return Principal$1.anonymous()}async transformRequest(request2){return Object.assign(Object.assign({},request2),{body:{content:request2.body}})}};__name(_AnonymousIdentity,"AnonymousIdentity");let AnonymousIdentity=_AnonymousIdentity;function createIdentityDescriptor(identity){return"getPublicKey"in identity?{type:"PublicKeyIdentity",publicKey:toHex(identity.getPublicKey().toDer())}:{type:"AnonymousIdentity"}}__name(createIdentityDescriptor,"createIdentityDescriptor");const _PrincipalEncoder=class _PrincipalEncoder{get name(){return"Principal"}get priority(){return 0}match(value){return value&&value._isPrincipal===!0}encode(v){return src.value.bytes(v.toUint8Array())}};__name(_PrincipalEncoder,"PrincipalEncoder");let PrincipalEncoder=_PrincipalEncoder;const _BufferEncoder=class _BufferEncoder{get name(){return"Buffer"}get priority(){return 1}match(value){return value instanceof ArrayBuffer||ArrayBuffer.isView(value)}encode(v){return src.value.bytes(new Uint8Array(v))}};__name(_BufferEncoder,"BufferEncoder");let BufferEncoder=_BufferEncoder;const _BigIntEncoder=class _BigIntEncoder{get name(){return"BigInt"}get priority(){return 1}match(value){return typeof value=="bigint"}encode(v){return v>BigInt(0)?src.value.tagged(2,src.value.bytes(fromHex(v.toString(16)))):src.value.tagged(3,src.value.bytes(fromHex((BigInt("-1")*v).toString(16))))}};__name(_BigIntEncoder,"BigIntEncoder");let BigIntEncoder=_BigIntEncoder;const serializer=src.SelfDescribeCborSerializer.withDefaultEncoders(!0);serializer.addEncoder(new PrincipalEncoder);serializer.addEncoder(new BufferEncoder);serializer.addEncoder(new BigIntEncoder);var CborTag;(function(CborTag2){CborTag2[CborTag2.Uint64LittleEndian=71]="Uint64LittleEndian",CborTag2[CborTag2.Semantic=55799]="Semantic"})(CborTag||(CborTag={}));function encode(value){return serializer.serialize(value)}__name(encode,"encode");function decodePositiveBigInt(buf){const len=buf.byteLength;let res=BigInt(0);for(let i=0;i<len;i++)res=res*BigInt(256)+BigInt(buf[i]);return res}__name(decodePositiveBigInt,"decodePositiveBigInt");const _Uint8ArrayDecoder=class _Uint8ArrayDecoder extends borc.Decoder{createByteString(raw){return concat$1(...raw)}createByteStringFromHeap(start,end){return start===end?new ArrayBuffer(0):new Uint8Array(this._heap.slice(start,end))}};__name(_Uint8ArrayDecoder,"Uint8ArrayDecoder");let Uint8ArrayDecoder=_Uint8ArrayDecoder;function decode(input){const buffer2=new Uint8Array(input),decoder=new Uint8ArrayDecoder({size:buffer2.byteLength,tags:{2:val=>decodePositiveBigInt(val),3:val=>-decodePositiveBigInt(val),[CborTag.Semantic]:value=>value}});try{return decoder.decodeFirst(buffer2)}catch(e){throw new Error(`Failed to decode CBOR: ${e}, input: ${toHex(buffer2)}`)}}__name(decode,"decode");const cbor=Object.freeze(Object.defineProperty({__proto__:null,get CborTag(){return CborTag},decode,encode},Symbol.toStringTag,{value:"Module"})),randomNumber=__name(()=>{if(typeof window<"u"&&window.crypto&&window.crypto.getRandomValues){const array=new Uint32Array(1);return window.crypto.getRandomValues(array),array[0]}if(typeof crypto<"u"&&crypto.getRandomValues){const array=new Uint32Array(1);return crypto.getRandomValues(array),array[0]}return typeof crypto<"u"&&crypto.randomInt?crypto.randomInt(0,4294967295):Math.floor(Math.random()*4294967295)},"randomNumber");var SubmitRequestType;(function(SubmitRequestType2){SubmitRequestType2.Call="call"})(SubmitRequestType||(SubmitRequestType={}));function makeNonce(){const buffer2=new ArrayBuffer(16),view=new DataView(buffer2),rand1=randomNumber(),rand2=randomNumber(),rand3=randomNumber(),rand4=randomNumber();return view.setUint32(0,rand1),view.setUint32(4,rand2),view.setUint32(8,rand3),view.setUint32(12,rand4),buffer2}__name(makeNonce,"makeNonce");const NANOSECONDS_PER_MILLISECONDS=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1e6),REPLICA_PERMITTED_DRIFT_MILLISECONDS=60*1e3,_Expiry=class _Expiry{constructor(deltaInMSec){if(deltaInMSec<90*1e3){const ingress_as_seconds2=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(Date.now()+deltaInMSec)*NANOSECONDS_PER_MILLISECONDS/(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1e9);this._value=ingress_as_seconds2*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1e9);return}const rounded_down_nanos=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(Math.floor(Date.now()+deltaInMSec-REPLICA_PERMITTED_DRIFT_MILLISECONDS))*NANOSECONDS_PER_MILLISECONDS/(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1e9)/(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(60)*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(60)*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1e9);this._value=rounded_down_nanos}toCBOR(){return src.value.u64(this._value.toString(16),16)}toHash(){return lebEncode(this._value)}};__name(_Expiry,"Expiry");let Expiry=_Expiry;function makeNonceTransform(nonceFn=makeNonce){return async request2=>{const headers=request2.request.headers;request2.request.headers=headers,request2.endpoint==="call"&&(request2.body.nonce=nonceFn())}}__name(makeNonceTransform,"makeNonceTransform");function makeExpiryTransform(delayInMilliseconds){return async request2=>{request2.body.ingress_expiry=new Expiry(delayInMilliseconds)}}__name(makeExpiryTransform,"makeExpiryTransform");function httpHeadersTransform(headers){const headerFields=[];return headers.forEach((value,key)=>{headerFields.push([key,value])}),headerFields}__name(httpHeadersTransform,"httpHeadersTransform");const _AgentHTTPResponseError=class _AgentHTTPResponseError extends AgentError{constructor(message,response){super(message),this.response=response,this.name=this.constructor.name,Object.setPrototypeOf(this,new.target.prototype)}};__name(_AgentHTTPResponseError,"AgentHTTPResponseError");let AgentHTTPResponseError=_AgentHTTPResponseError;const _AgentCallError=class _AgentCallError extends AgentError{constructor(message,response,requestId,senderPubkey,senderSig,ingressExpiry){super(message),this.response=response,this.requestId=requestId,this.senderPubkey=senderPubkey,this.senderSig=senderSig,this.ingressExpiry=ingressExpiry,this.name="AgentCallError",Object.setPrototypeOf(this,new.target.prototype)}};__name(_AgentCallError,"AgentCallError");let AgentCallError=_AgentCallError;const _AgentQueryError=class _AgentQueryError extends AgentError{constructor(message,response,requestId,senderPubkey,senderSig,ingressExpiry){super(message),this.response=response,this.requestId=requestId,this.senderPubkey=senderPubkey,this.senderSig=senderSig,this.ingressExpiry=ingressExpiry,this.name="AgentQueryError",Object.setPrototypeOf(this,new.target.prototype)}};__name(_AgentQueryError,"AgentQueryError");let AgentQueryError=_AgentQueryError;const _AgentReadStateError=class _AgentReadStateError extends AgentError{constructor(message,response,requestId,senderPubkey,senderSig,ingressExpiry){super(message),this.response=response,this.requestId=requestId,this.senderPubkey=senderPubkey,this.senderSig=senderSig,this.ingressExpiry=ingressExpiry,this.name="AgentReadStateError",Object.setPrototypeOf(this,new.target.prototype)}};__name(_AgentReadStateError,"AgentReadStateError");let AgentReadStateError=_AgentReadStateError,verify;function blsVerify(pk,sig,msg){const primaryKey=typeof pk=="string"?pk:toHex(pk),signature=typeof sig=="string"?sig:toHex(sig),message=typeof msg=="string"?msg:toHex(msg);return bls12_381.verifyShortSignature(signature,message,primaryKey)}__name(blsVerify,"blsVerify");const decodeLeb128=__name(buf=>lebDecode(new PipeArrayBuffer(buf)),"decodeLeb128"),decodeTime=__name(buf=>{const decoded=decodeLeb128(buf);return new Date(Number(decoded)/1e6)},"decodeTime");var __classPrivateFieldSet$8=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$8=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_Certificate_disableTimeVerification;const _CertificateVerificationError=class _CertificateVerificationError extends AgentError{constructor(reason){super(`Invalid certificate: ${reason}`)}};__name(_CertificateVerificationError,"CertificateVerificationError");let CertificateVerificationError=_CertificateVerificationError;var NodeType;(function(NodeType2){NodeType2[NodeType2.Empty=0]="Empty",NodeType2[NodeType2.Fork=1]="Fork",NodeType2[NodeType2.Labeled=2]="Labeled",NodeType2[NodeType2.Leaf=3]="Leaf",NodeType2[NodeType2.Pruned=4]="Pruned"})(NodeType||(NodeType={}));function hashTreeToString(tree){const indent=__name(s=>s.split(`
`).map(x=>"  "+x).join(`
`),"indent");function labelToString(label){const decoder=new TextDecoder(void 0,{fatal:!0});try{return JSON.stringify(decoder.decode(label))}catch{return`data(...${label.byteLength} bytes)`}}switch(__name(labelToString,"labelToString"),tree[0]){case NodeType.Empty:return"()";case NodeType.Fork:if(tree[1]instanceof Array&&tree[2]instanceof ArrayBuffer){const left=hashTreeToString(tree[1]),right=hashTreeToString(tree[2]);return`sub(
 left:
${indent(left)}
---
 right:
${indent(right)}
)`}else throw new Error("Invalid tree structure for fork");case NodeType.Labeled:if(tree[1]instanceof ArrayBuffer&&tree[2]instanceof ArrayBuffer){const label=labelToString(tree[1]),sub=hashTreeToString(tree[2]);return`label(
 label:
${indent(label)}
 sub:
${indent(sub)}
)`}else throw new Error("Invalid tree structure for labeled");case NodeType.Leaf:{if(tree[1]){if(Array.isArray(tree[1]))return JSON.stringify(tree[1])}else throw new Error("Invalid tree structure for leaf");return`leaf(...${tree[1].byteLength} bytes)`}case NodeType.Pruned:{if(tree[1]){if(Array.isArray(tree[1]))return JSON.stringify(tree[1])}else throw new Error("Invalid tree structure for pruned");return`pruned(${toHex(new Uint8Array(tree[1]))}`}default:return`unknown(${JSON.stringify(tree[0])})`}}__name(hashTreeToString,"hashTreeToString");function isBufferGreaterThan(a,b){const a8=new Uint8Array(a),b8=new Uint8Array(b);for(let i=0;i<a8.length;i++)if(a8[i]>b8[i])return!0;return!1}__name(isBufferGreaterThan,"isBufferGreaterThan");const _Certificate=class _Certificate{constructor(certificate,_rootKey,_canisterId,_blsVerify,_maxAgeInMinutes=5,disableTimeVerification=!1){this._rootKey=_rootKey,this._canisterId=_canisterId,this._blsVerify=_blsVerify,this._maxAgeInMinutes=_maxAgeInMinutes,_Certificate_disableTimeVerification.set(this,!1),__classPrivateFieldSet$8(this,_Certificate_disableTimeVerification,disableTimeVerification,"f"),this.cert=decode(new Uint8Array(certificate))}static async create(options){const cert=_Certificate.createUnverified(options);return await cert.verify(),cert}static createUnverified(options){let blsVerify$1=options.blsVerify;return blsVerify$1||(blsVerify$1=blsVerify),new _Certificate(options.certificate,options.rootKey,options.canisterId,blsVerify$1,options.maxAgeInMinutes,options.disableTimeVerification)}lookup(path){return lookup_path(path,this.cert.tree)}lookup_label(label){return this.lookup([label])}async verify(){const rootHash=await reconstruct(this.cert.tree),derKey=await this._checkDelegationAndGetKey(this.cert.delegation),sig=this.cert.signature,key=extractDER(derKey),msg=concat$1(domain_sep("ic-state-root"),rootHash);let sigVer=!1;const lookupTime=lookupResultToBuffer(this.lookup(["time"]));if(!lookupTime)throw new CertificateVerificationError("Certificate does not contain a time");if(!__classPrivateFieldGet$8(this,_Certificate_disableTimeVerification,"f")){const MAX_AGE_IN_MSEC=this._maxAgeInMinutes*60*1e3,now=Date.now(),earliestCertificateTime=now-MAX_AGE_IN_MSEC,fiveMinutesFromNow=now+3e5,certTime=decodeTime(lookupTime);if(certTime.getTime()<earliestCertificateTime)throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: `+certTime.toISOString()+" Current time: "+new Date(now).toISOString());if(certTime.getTime()>fiveMinutesFromNow)throw new CertificateVerificationError("Certificate is signed more than 5 minutes in the future. Certificate time: "+certTime.toISOString()+" Current time: "+new Date(now).toISOString())}try{sigVer=await this._blsVerify(new Uint8Array(key),new Uint8Array(sig),new Uint8Array(msg))}catch{sigVer=!1}if(!sigVer)throw new CertificateVerificationError("Signature verification failed")}async _checkDelegationAndGetKey(d){if(!d)return this._rootKey;const cert=await _Certificate.createUnverified({certificate:d.certificate,rootKey:this._rootKey,canisterId:this._canisterId,blsVerify:this._blsVerify,maxAgeInMinutes:1/0});if(cert.cert.delegation)throw new CertificateVerificationError("Delegation certificates cannot be nested");if(await cert.verify(),this._canisterId.toString()!==MANAGEMENT_CANISTER_ID&&!check_canister_ranges({canisterId:this._canisterId,subnetId:Principal$1.fromUint8Array(new Uint8Array(d.subnet_id)),tree:cert.cert.tree}))throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(d.subnet_id)}`);const publicKeyLookup=lookupResultToBuffer(cert.lookup(["subnet",d.subnet_id,"public_key"]));if(!publicKeyLookup)throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);return publicKeyLookup}};__name(_Certificate,"Certificate");let Certificate=_Certificate;_Certificate_disableTimeVerification=new WeakMap;const DER_PREFIX=fromHex("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100"),KEY_LENGTH=96;function extractDER(buf){const expectedLength=DER_PREFIX.byteLength+KEY_LENGTH;if(buf.byteLength!==expectedLength)throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);const prefix=buf.slice(0,DER_PREFIX.byteLength);if(!bufEquals(prefix,DER_PREFIX))throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);return buf.slice(DER_PREFIX.byteLength)}__name(extractDER,"extractDER");function lookupResultToBuffer(result){if(result.status===LookupStatus.Found){if(result.value instanceof ArrayBuffer)return result.value;if(result.value instanceof Uint8Array)return result.value.buffer}}__name(lookupResultToBuffer,"lookupResultToBuffer");async function reconstruct(t){switch(t[0]){case NodeType.Empty:return hash(domain_sep("ic-hashtree-empty"));case NodeType.Pruned:return t[1];case NodeType.Leaf:return hash(concat$1(domain_sep("ic-hashtree-leaf"),t[1]));case NodeType.Labeled:return hash(concat$1(domain_sep("ic-hashtree-labeled"),t[1],await reconstruct(t[2])));case NodeType.Fork:return hash(concat$1(domain_sep("ic-hashtree-fork"),await reconstruct(t[1]),await reconstruct(t[2])));default:throw new Error("unreachable")}}__name(reconstruct,"reconstruct");function domain_sep(s){const len=new Uint8Array([s.length]),str=new TextEncoder().encode(s);return concat$1(len,str)}__name(domain_sep,"domain_sep");var LookupStatus;(function(LookupStatus2){LookupStatus2.Unknown="unknown",LookupStatus2.Absent="absent",LookupStatus2.Found="found"})(LookupStatus||(LookupStatus={}));var LabelLookupStatus;(function(LabelLookupStatus2){LabelLookupStatus2.Less="less",LabelLookupStatus2.Greater="greater"})(LabelLookupStatus||(LabelLookupStatus={}));function lookup_path(path,tree){if(path.length===0)switch(tree[0]){case NodeType.Leaf:{if(!tree[1])throw new Error("Invalid tree structure for leaf");return tree[1]instanceof ArrayBuffer?{status:LookupStatus.Found,value:tree[1]}:tree[1]instanceof Uint8Array?{status:LookupStatus.Found,value:tree[1].buffer}:{status:LookupStatus.Found,value:tree[1]}}default:return{status:LookupStatus.Found,value:tree}}const label=typeof path[0]=="string"?new TextEncoder().encode(path[0]):path[0],lookupResult=find_label(label,tree);switch(lookupResult.status){case LookupStatus.Found:return lookup_path(path.slice(1),lookupResult.value);case LabelLookupStatus.Greater:case LabelLookupStatus.Less:return{status:LookupStatus.Absent};default:return lookupResult}}__name(lookup_path,"lookup_path");function flatten_forks(t){switch(t[0]){case NodeType.Empty:return[];case NodeType.Fork:return flatten_forks(t[1]).concat(flatten_forks(t[2]));default:return[t]}}__name(flatten_forks,"flatten_forks");function find_label(label,tree){switch(tree[0]){case NodeType.Labeled:return isBufferGreaterThan(label,tree[1])?{status:LabelLookupStatus.Greater}:bufEquals(label,tree[1])?{status:LookupStatus.Found,value:tree[2]}:{status:LabelLookupStatus.Less};case NodeType.Fork:const leftLookupResult=find_label(label,tree[1]);switch(leftLookupResult.status){case LabelLookupStatus.Greater:{const rightLookupResult=find_label(label,tree[2]);return rightLookupResult.status===LabelLookupStatus.Less?{status:LookupStatus.Absent}:rightLookupResult}case LookupStatus.Unknown:{let rightLookupResult=find_label(label,tree[2]);return rightLookupResult.status===LabelLookupStatus.Less?{status:LookupStatus.Unknown}:rightLookupResult}default:return leftLookupResult}case NodeType.Pruned:return{status:LookupStatus.Unknown};default:return{status:LookupStatus.Absent}}}__name(find_label,"find_label");function check_canister_ranges(params){const{canisterId,subnetId,tree}=params,rangeLookup=lookup_path(["subnet",subnetId.toUint8Array(),"canister_ranges"],tree);if(rangeLookup.status!==LookupStatus.Found||!(rangeLookup.value instanceof ArrayBuffer))throw new Error(`Could not find canister ranges for subnet ${subnetId}`);return decode(rangeLookup.value).map(v=>[Principal$1.fromUint8Array(v[0]),Principal$1.fromUint8Array(v[1])]).some(r=>r[0].ltEq(canisterId)&&r[1].gtEq(canisterId))}__name(check_canister_ranges,"check_canister_ranges");const _CustomPath=class _CustomPath{constructor(key,path,decodeStrategy){this.key=key,this.path=path,this.decodeStrategy=decodeStrategy}};__name(_CustomPath,"CustomPath");let CustomPath=_CustomPath;const request=__name(async options=>{const{agent,paths}=options,canisterId=Principal$1.from(options.canisterId),uniquePaths=[...new Set(paths)],encodedPaths=uniquePaths.map(path=>encodePath(path,canisterId)),status=new Map,promises=uniquePaths.map((path,index2)=>(async()=>{var _a4;try{const response=await agent.readState(canisterId,{paths:[encodedPaths[index2]]});if(agent.rootKey==null)throw new Error("Agent is missing root key");const cert=await Certificate.create({certificate:response.certificate,rootKey:agent.rootKey,canisterId,disableTimeVerification:!0}),lookup=__name((cert2,path3)=>{if(path3==="subnet"){if(agent.rootKey==null)throw new Error("Agent is missing root key");const data2=fetchNodeKeys(response.certificate,canisterId,agent.rootKey);return{path:path3,data:data2}}else return{path:path3,data:lookupResultToBuffer(cert2.lookup(encodePath(path3,canisterId)))}},"lookup"),{path:path2,data}=lookup(cert,uniquePaths[index2]);if(!data)console.warn(`Expected to find result for path ${path2}, but instead found nothing.`),typeof path2=="string"?status.set(path2,null):status.set(path2.key,null);else switch(path2){case"time":{status.set(path2,decodeTime(data));break}case"controllers":{status.set(path2,decodeControllers(data));break}case"module_hash":{status.set(path2,decodeHex(data));break}case"subnet":{status.set(path2,data);break}case"candid":{status.set(path2,new TextDecoder().decode(data));break}default:if(typeof path2!="string"&&"key"in path2&&"path"in path2)switch(path2.decodeStrategy){case"raw":status.set(path2.key,data);break;case"leb128":{status.set(path2.key,decodeLeb128(data));break}case"cbor":{status.set(path2.key,decodeCbor(data));break}case"hex":{status.set(path2.key,decodeHex(data));break}case"utf-8":status.set(path2.key,decodeUtf8(data))}}}catch(error){if(!((_a4=error?.message)===null||_a4===void 0)&&_a4.includes("Invalid certificate"))throw new AgentError(error.message);typeof path!="string"&&"key"in path&&"path"in path?status.set(path.key,null):status.set(path,null),console.group(),console.warn(`Expected to find result for path ${path}, but instead found nothing.`),console.warn(error),console.groupEnd()}})());return await Promise.all(promises),status},"request"),fetchNodeKeys=__name((certificate,canisterId,root_key)=>{if(!canisterId._isPrincipal)throw new Error("Invalid canisterId");const cert=decode(new Uint8Array(certificate)),tree=cert.tree;let delegation=cert.delegation,subnetId;if(delegation&&delegation.subnet_id?subnetId=Principal$1.fromUint8Array(new Uint8Array(delegation.subnet_id)):!delegation&&typeof root_key<"u"?(subnetId=Principal$1.selfAuthenticating(new Uint8Array(root_key)),delegation={subnet_id:subnetId.toUint8Array(),certificate:new ArrayBuffer(0)}):(subnetId=Principal$1.selfAuthenticating(Principal$1.fromText("tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe").toUint8Array()),delegation={subnet_id:subnetId.toUint8Array(),certificate:new ArrayBuffer(0)}),!check_canister_ranges({canisterId,subnetId,tree}))throw new Error("Canister not in range");const subnetLookupResult=lookup_path(["subnet",delegation.subnet_id,"node"],tree);if(subnetLookupResult.status!==LookupStatus.Found)throw new Error("Node not found");if(subnetLookupResult.value instanceof ArrayBuffer)throw new Error("Invalid node tree");const nodeForks=flatten_forks(subnetLookupResult.value),nodeKeys=new Map;return nodeForks.forEach(fork=>{const node_id=Principal$1.from(new Uint8Array(fork[1])).toText(),publicKeyLookupResult=lookup_path(["public_key"],fork[2]);if(publicKeyLookupResult.status!==LookupStatus.Found)throw new Error("Public key not found");const derEncodedPublicKey=publicKeyLookupResult.value;if(derEncodedPublicKey.byteLength!==44)throw new Error("Invalid public key length");nodeKeys.set(node_id,derEncodedPublicKey)}),{subnetId:Principal$1.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),nodeKeys}},"fetchNodeKeys"),encodePath=__name((path,canisterId)=>{const encoder=new TextEncoder,encode2=__name(arg=>new DataView(encoder.encode(arg).buffer).buffer,"encode"),canisterBuffer=new DataView(canisterId.toUint8Array().buffer).buffer;switch(path){case"time":return[encode2("time")];case"controllers":return[encode2("canister"),canisterBuffer,encode2("controllers")];case"module_hash":return[encode2("canister"),canisterBuffer,encode2("module_hash")];case"subnet":return[encode2("subnet")];case"candid":return[encode2("canister"),canisterBuffer,encode2("metadata"),encode2("candid:service")];default:if("key"in path&&"path"in path)if(typeof path.path=="string"||path.path instanceof ArrayBuffer){const metaPath=path.path,encoded=typeof metaPath=="string"?encode2(metaPath):metaPath;return[encode2("canister"),canisterBuffer,encode2("metadata"),encoded]}else return path.path}throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`)},"encodePath"),decodeHex=__name(buf=>toHex(buf),"decodeHex"),decodeCbor=__name(buf=>decode(buf),"decodeCbor"),decodeUtf8=__name(buf=>new TextDecoder().decode(buf),"decodeUtf8"),decodeControllers=__name(buf=>decodeCbor(buf).map(buf2=>Principal$1.fromUint8Array(new Uint8Array(buf2))),"decodeControllers"),index$2=Object.freeze(Object.defineProperty({__proto__:null,CustomPath,encodePath,fetchNodeKeys,request},Symbol.toStringTag,{value:"Module"}));var __classPrivateFieldSet$7=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$7=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_ExpirableMap_inner,_ExpirableMap_expirationTime,_a2,_b;const _ExpirableMap=class _ExpirableMap{constructor(options={}){_ExpirableMap_inner.set(this,void 0),_ExpirableMap_expirationTime.set(this,void 0),this[_a2]=this.entries.bind(this),this[_b]="ExpirableMap";const{source=[],expirationTime=10*60*1e3}=options,currentTime=Date.now();__classPrivateFieldSet$7(this,_ExpirableMap_inner,new Map([...source].map(([key,value])=>[key,{value,timestamp:currentTime}])),"f"),__classPrivateFieldSet$7(this,_ExpirableMap_expirationTime,expirationTime,"f")}prune(){const currentTime=Date.now();for(const[key,entry]of __classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").entries())currentTime-entry.timestamp>__classPrivateFieldGet$7(this,_ExpirableMap_expirationTime,"f")&&__classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").delete(key);return this}set(key,value){this.prune();const entry={value,timestamp:Date.now()};return __classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").set(key,entry),this}get(key){const entry=__classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").get(key);if(entry!==void 0){if(Date.now()-entry.timestamp>__classPrivateFieldGet$7(this,_ExpirableMap_expirationTime,"f")){__classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").delete(key);return}return entry.value}}clear(){__classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").clear()}entries(){const iterator=__classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").entries();return __name(function*(){for(const[key,value]of iterator)yield[key,value.value]},"generator")()}values(){const iterator=__classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").values();return __name(function*(){for(const value of iterator)yield value.value},"generator")()}keys(){return __classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").keys()}forEach(callbackfn,thisArg){for(const[key,value]of __classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").entries())callbackfn.call(thisArg,value.value,key,this)}has(key){return __classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").has(key)}delete(key){return __classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").delete(key)}get size(){return __classPrivateFieldGet$7(this,_ExpirableMap_inner,"f").size}};__name(_ExpirableMap,"ExpirableMap");let ExpirableMap=_ExpirableMap;_ExpirableMap_inner=new WeakMap,_ExpirableMap_expirationTime=new WeakMap,_a2=Symbol.iterator,_b=Symbol.toStringTag;const encodeLenBytes=__name(len=>{if(len<=127)return 1;if(len<=255)return 2;if(len<=65535)return 3;if(len<=16777215)return 4;throw new Error("Length too long (> 4 bytes)")},"encodeLenBytes"),encodeLen=__name((buf,offset,len)=>{if(len<=127)return buf[offset]=len,1;if(len<=255)return buf[offset]=129,buf[offset+1]=len,2;if(len<=65535)return buf[offset]=130,buf[offset+1]=len>>8,buf[offset+2]=len,3;if(len<=16777215)return buf[offset]=131,buf[offset+1]=len>>16,buf[offset+2]=len>>8,buf[offset+3]=len,4;throw new Error("Length too long (> 4 bytes)")},"encodeLen"),decodeLenBytes=__name((buf,offset)=>{if(buf[offset]<128)return 1;if(buf[offset]===128)throw new Error("Invalid length 0");if(buf[offset]===129)return 2;if(buf[offset]===130)return 3;if(buf[offset]===131)return 4;throw new Error("Length too long (> 4 bytes)")},"decodeLenBytes"),decodeLen=__name((buf,offset)=>{const lenBytes=decodeLenBytes(buf,offset);if(lenBytes===1)return buf[offset];if(lenBytes===2)return buf[offset+1];if(lenBytes===3)return(buf[offset+1]<<8)+buf[offset+2];if(lenBytes===4)return(buf[offset+1]<<16)+(buf[offset+2]<<8)+buf[offset+3];throw new Error("Length too long (> 4 bytes)")},"decodeLen"),DER_COSE_OID=Uint8Array.from([48,12,6,10,43,6,1,4,1,131,184,67,1,1]),ED25519_OID=Uint8Array.from([48,5,6,3,43,101,112]),SECP256K1_OID=Uint8Array.from([48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,10]);function wrapDER(payload,oid){const bitStringHeaderLength=2+encodeLenBytes(payload.byteLength+1),len=oid.byteLength+bitStringHeaderLength+payload.byteLength;let offset=0;const buf=new Uint8Array(1+encodeLenBytes(len)+len);return buf[offset++]=48,offset+=encodeLen(buf,offset,len),buf.set(oid,offset),offset+=oid.byteLength,buf[offset++]=3,offset+=encodeLen(buf,offset,payload.byteLength+1),buf[offset++]=0,buf.set(new Uint8Array(payload),offset),buf}__name(wrapDER,"wrapDER");const unwrapDER=__name((derEncoded,oid)=>{let offset=0;const expect=__name((n,msg)=>{if(buf[offset++]!==n)throw new Error("Expected: "+msg)},"expect"),buf=new Uint8Array(derEncoded);if(expect(48,"sequence"),offset+=decodeLenBytes(buf,offset),!bufEquals(buf.slice(offset,offset+oid.byteLength),oid))throw new Error("Not the expected OID.");offset+=oid.byteLength,expect(3,"bit string");const payloadLen=decodeLen(buf,offset)-1;offset+=decodeLenBytes(buf,offset),expect(0,"0 padding");const result=buf.slice(offset);if(payloadLen!==result.length)throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);return result},"unwrapDER");var __classPrivateFieldSet$6=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$6=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_Ed25519PublicKey_rawKey$1,_Ed25519PublicKey_derKey$1,_a3;let Ed25519PublicKey$1=(_a3=class{constructor(key){if(_Ed25519PublicKey_rawKey$1.set(this,void 0),_Ed25519PublicKey_derKey$1.set(this,void 0),key.byteLength!==_a3.RAW_KEY_LENGTH)throw new Error("An Ed25519 public key must be exactly 32bytes long");__classPrivateFieldSet$6(this,_Ed25519PublicKey_rawKey$1,key,"f"),__classPrivateFieldSet$6(this,_Ed25519PublicKey_derKey$1,_a3.derEncode(key),"f")}static from(key){return this.fromDer(key.toDer())}static fromRaw(rawKey){return new _a3(rawKey)}static fromDer(derKey){return new _a3(this.derDecode(derKey))}static derEncode(publicKey){return wrapDER(publicKey,ED25519_OID).buffer}static derDecode(key){const unwrapped=unwrapDER(key,ED25519_OID);if(unwrapped.length!==this.RAW_KEY_LENGTH)throw new Error("An Ed25519 public key must be exactly 32bytes long");return unwrapped}get rawKey(){return __classPrivateFieldGet$6(this,_Ed25519PublicKey_rawKey$1,"f")}get derKey(){return __classPrivateFieldGet$6(this,_Ed25519PublicKey_derKey$1,"f")}toDer(){return this.derKey}toRaw(){return this.rawKey}},__name(_a3,"Ed25519PublicKey"),_a3);_Ed25519PublicKey_rawKey$1=new WeakMap,_Ed25519PublicKey_derKey$1=new WeakMap;Ed25519PublicKey$1.RAW_KEY_LENGTH=32;const _Observable=class _Observable{constructor(){this.observers=[]}subscribe(func){this.observers.push(func)}unsubscribe(func){this.observers=this.observers.filter(observer=>observer!==func)}notify(data,...rest){this.observers.forEach(observer=>observer(data,...rest))}};__name(_Observable,"Observable");let Observable=_Observable;const _ObservableLog=class _ObservableLog extends Observable{constructor(){super()}print(message,...rest){this.notify({message,level:"info"},...rest)}warn(message,...rest){this.notify({message,level:"warn"},...rest)}error(message,error,...rest){this.notify({message,level:"error",error},...rest)}};__name(_ObservableLog,"ObservableLog");let ObservableLog=_ObservableLog;var __classPrivateFieldSet$5=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$5=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_ExponentialBackoff_currentInterval,_ExponentialBackoff_randomizationFactor,_ExponentialBackoff_multiplier,_ExponentialBackoff_maxInterval,_ExponentialBackoff_startTime,_ExponentialBackoff_maxElapsedTime,_ExponentialBackoff_maxIterations,_ExponentialBackoff_date,_ExponentialBackoff_count;const RANDOMIZATION_FACTOR=.5,MULTIPLIER=1.5,INITIAL_INTERVAL_MSEC=500,MAX_INTERVAL_MSEC=6e4,MAX_ELAPSED_TIME_MSEC=9e5,MAX_ITERATIONS=10,_ExponentialBackoff=class _ExponentialBackoff{constructor(options=_ExponentialBackoff.default){_ExponentialBackoff_currentInterval.set(this,void 0),_ExponentialBackoff_randomizationFactor.set(this,void 0),_ExponentialBackoff_multiplier.set(this,void 0),_ExponentialBackoff_maxInterval.set(this,void 0),_ExponentialBackoff_startTime.set(this,void 0),_ExponentialBackoff_maxElapsedTime.set(this,void 0),_ExponentialBackoff_maxIterations.set(this,void 0),_ExponentialBackoff_date.set(this,void 0),_ExponentialBackoff_count.set(this,0);const{initialInterval=INITIAL_INTERVAL_MSEC,randomizationFactor=RANDOMIZATION_FACTOR,multiplier=MULTIPLIER,maxInterval=MAX_INTERVAL_MSEC,maxElapsedTime=MAX_ELAPSED_TIME_MSEC,maxIterations=MAX_ITERATIONS,date=Date}=options;__classPrivateFieldSet$5(this,_ExponentialBackoff_currentInterval,initialInterval,"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_randomizationFactor,randomizationFactor,"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_multiplier,multiplier,"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_maxInterval,maxInterval,"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_date,date,"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_startTime,date.now(),"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_maxElapsedTime,maxElapsedTime,"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_maxIterations,maxIterations,"f")}get ellapsedTimeInMsec(){return __classPrivateFieldGet$5(this,_ExponentialBackoff_date,"f").now()-__classPrivateFieldGet$5(this,_ExponentialBackoff_startTime,"f")}get currentInterval(){return __classPrivateFieldGet$5(this,_ExponentialBackoff_currentInterval,"f")}get count(){return __classPrivateFieldGet$5(this,_ExponentialBackoff_count,"f")}get randomValueFromInterval(){const delta=__classPrivateFieldGet$5(this,_ExponentialBackoff_randomizationFactor,"f")*__classPrivateFieldGet$5(this,_ExponentialBackoff_currentInterval,"f"),min=__classPrivateFieldGet$5(this,_ExponentialBackoff_currentInterval,"f")-delta,max=__classPrivateFieldGet$5(this,_ExponentialBackoff_currentInterval,"f")+delta;return Math.random()*(max-min)+min}incrementCurrentInterval(){var _a4;return __classPrivateFieldSet$5(this,_ExponentialBackoff_currentInterval,Math.min(__classPrivateFieldGet$5(this,_ExponentialBackoff_currentInterval,"f")*__classPrivateFieldGet$5(this,_ExponentialBackoff_multiplier,"f"),__classPrivateFieldGet$5(this,_ExponentialBackoff_maxInterval,"f")),"f"),__classPrivateFieldSet$5(this,_ExponentialBackoff_count,(_a4=__classPrivateFieldGet$5(this,_ExponentialBackoff_count,"f"),_a4++,_a4),"f"),__classPrivateFieldGet$5(this,_ExponentialBackoff_currentInterval,"f")}next(){return this.ellapsedTimeInMsec>=__classPrivateFieldGet$5(this,_ExponentialBackoff_maxElapsedTime,"f")||__classPrivateFieldGet$5(this,_ExponentialBackoff_count,"f")>=__classPrivateFieldGet$5(this,_ExponentialBackoff_maxIterations,"f")?null:(this.incrementCurrentInterval(),this.randomValueFromInterval)}};__name(_ExponentialBackoff,"ExponentialBackoff");let ExponentialBackoff=_ExponentialBackoff;_ExponentialBackoff_currentInterval=new WeakMap,_ExponentialBackoff_randomizationFactor=new WeakMap,_ExponentialBackoff_multiplier=new WeakMap,_ExponentialBackoff_maxInterval=new WeakMap,_ExponentialBackoff_startTime=new WeakMap,_ExponentialBackoff_maxElapsedTime=new WeakMap,_ExponentialBackoff_maxIterations=new WeakMap,_ExponentialBackoff_date=new WeakMap,_ExponentialBackoff_count=new WeakMap;ExponentialBackoff.default={initialInterval:INITIAL_INTERVAL_MSEC,randomizationFactor:RANDOMIZATION_FACTOR,multiplier:MULTIPLIER,maxInterval:MAX_INTERVAL_MSEC,maxElapsedTime:MAX_ELAPSED_TIME_MSEC,maxIterations:MAX_ITERATIONS,date:Date};var __classPrivateFieldSet$4=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$4=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_HttpAgent_instances,_HttpAgent_rootKeyPromise,_HttpAgent_shouldFetchRootKey,_HttpAgent_identity,_HttpAgent_fetch,_HttpAgent_fetchOptions,_HttpAgent_callOptions,_HttpAgent_timeDiffMsecs,_HttpAgent_credentials,_HttpAgent_retryTimes,_HttpAgent_backoffStrategy,_HttpAgent_maxIngressExpiryInMinutes,_HttpAgent_waterMark,_HttpAgent_queryPipeline,_HttpAgent_updatePipeline,_HttpAgent_subnetKeys,_HttpAgent_verifyQuerySignatures,_HttpAgent_requestAndRetryQuery,_HttpAgent_requestAndRetry,_HttpAgent_verifyQueryResponse,_HttpAgent_rootKeyGuard,RequestStatusResponseStatus;(function(RequestStatusResponseStatus2){RequestStatusResponseStatus2.Received="received",RequestStatusResponseStatus2.Processing="processing",RequestStatusResponseStatus2.Replied="replied",RequestStatusResponseStatus2.Rejected="rejected",RequestStatusResponseStatus2.Unknown="unknown",RequestStatusResponseStatus2.Done="done"})(RequestStatusResponseStatus||(RequestStatusResponseStatus={}));const MINUTE_TO_MSECS=60*1e3,IC_ROOT_KEY="308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae",MANAGEMENT_CANISTER_ID="aaaaa-aa",IC0_DOMAIN="ic0.app",IC0_SUB_DOMAIN=".ic0.app",ICP0_DOMAIN="icp0.io",ICP0_SUB_DOMAIN=".icp0.io",ICP_API_DOMAIN="icp-api.io",ICP_API_SUB_DOMAIN=".icp-api.io",_HttpDefaultFetchError=class _HttpDefaultFetchError extends AgentError{constructor(message){super(message),this.message=message}};__name(_HttpDefaultFetchError,"HttpDefaultFetchError");let HttpDefaultFetchError=_HttpDefaultFetchError;const _IdentityInvalidError=class _IdentityInvalidError extends AgentError{constructor(message){super(message),this.message=message}};__name(_IdentityInvalidError,"IdentityInvalidError");let IdentityInvalidError=_IdentityInvalidError;function getDefaultFetch(){let defaultFetch;if(typeof window<"u")if(window.fetch)defaultFetch=window.fetch.bind(window);else throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");else if(typeof globalThis<"u")if(globalThis.fetch)defaultFetch=globalThis.fetch.bind(globalThis);else throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a Node.js context, but globalThis.fetch was not available.");else typeof self<"u"&&self.fetch&&(defaultFetch=self.fetch.bind(self));if(defaultFetch)return defaultFetch;throw new HttpDefaultFetchError("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or globalThis context.")}__name(getDefaultFetch,"getDefaultFetch");function determineHost(configuredHost){let host;if(configuredHost!==void 0)!configuredHost.match(/^[a-z]+:/)&&typeof window<"u"?host=new URL(window.location.protocol+"//"+configuredHost):host=new URL(configuredHost);else{const knownHosts=["ic0.app","icp0.io","127.0.0.1","localhost"],remoteHosts=[".github.dev",".gitpod.io"],location2=typeof window<"u"?window.location:void 0,hostname=location2?.hostname;let knownHost;hostname&&typeof hostname=="string"&&(remoteHosts.some(host2=>hostname.endsWith(host2))?knownHost=hostname:knownHost=knownHosts.find(host2=>hostname.endsWith(host2))),location2&&knownHost?host=new URL(`${location2.protocol}//${knownHost}${location2.port?":"+location2.port:""}`):host=new URL("https://icp-api.io")}return host.toString()}__name(determineHost,"determineHost");const _HttpAgent=class _HttpAgent{constructor(options={}){var _a4,_b2;_HttpAgent_instances.add(this),_HttpAgent_rootKeyPromise.set(this,null),_HttpAgent_shouldFetchRootKey.set(this,!1),_HttpAgent_identity.set(this,void 0),_HttpAgent_fetch.set(this,void 0),_HttpAgent_fetchOptions.set(this,void 0),_HttpAgent_callOptions.set(this,void 0),_HttpAgent_timeDiffMsecs.set(this,0),_HttpAgent_credentials.set(this,void 0),_HttpAgent_retryTimes.set(this,void 0),_HttpAgent_backoffStrategy.set(this,void 0),_HttpAgent_maxIngressExpiryInMinutes.set(this,void 0),this._isAgent=!0,this.config={},_HttpAgent_waterMark.set(this,0),this.log=new ObservableLog,_HttpAgent_queryPipeline.set(this,[]),_HttpAgent_updatePipeline.set(this,[]),_HttpAgent_subnetKeys.set(this,new ExpirableMap({expirationTime:5*60*1e3})),_HttpAgent_verifyQuerySignatures.set(this,!0),_HttpAgent_verifyQueryResponse.set(this,(queryResponse,subnetStatus)=>{if(__classPrivateFieldGet$4(this,_HttpAgent_verifyQuerySignatures,"f")===!1)return queryResponse;if(!subnetStatus)throw new CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");const{status,signatures=[],requestId}=queryResponse,domainSeparator2=bufFromBufLike$1(new TextEncoder().encode("\vic-response"));for(const sig of signatures){const{timestamp,identity}=sig,nodeId=Principal$1.fromUint8Array(identity).toText();let hash2;if(status==="replied"){const{reply}=queryResponse;hash2=hashOfMap({status,reply,timestamp:BigInt(timestamp),request_id:requestId})}else if(status==="rejected"){const{reject_code,reject_message,error_code}=queryResponse;hash2=hashOfMap({status,reject_code,reject_message,error_code,timestamp:BigInt(timestamp),request_id:requestId})}else throw new Error(`Unknown status: ${status}`);const separatorWithHash=concat$1(domainSeparator2,bufFromBufLike$1(new Uint8Array(hash2))),pubKey=subnetStatus?.nodeKeys.get(nodeId);if(!pubKey)throw new CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");const rawKey=Ed25519PublicKey$1.fromDer(pubKey).rawKey;if(ed25519.verify(sig.signature,new Uint8Array(separatorWithHash),new Uint8Array(rawKey)))return queryResponse;throw new CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`)}return queryResponse}),this.config=options,__classPrivateFieldSet$4(this,_HttpAgent_fetch,options.fetch||getDefaultFetch()||fetch.bind(globalThis),"f"),__classPrivateFieldSet$4(this,_HttpAgent_fetchOptions,options.fetchOptions,"f"),__classPrivateFieldSet$4(this,_HttpAgent_callOptions,options.callOptions,"f"),__classPrivateFieldSet$4(this,_HttpAgent_shouldFetchRootKey,(_a4=options.shouldFetchRootKey)!==null&&_a4!==void 0?_a4:!1,"f"),options.rootKey?this.rootKey=options.rootKey:__classPrivateFieldGet$4(this,_HttpAgent_shouldFetchRootKey,"f")?this.rootKey=null:this.rootKey=fromHex(IC_ROOT_KEY);const host=determineHost(options.host);this.host=new URL(host),options.verifyQuerySignatures!==void 0&&__classPrivateFieldSet$4(this,_HttpAgent_verifyQuerySignatures,options.verifyQuerySignatures,"f"),__classPrivateFieldSet$4(this,_HttpAgent_retryTimes,(_b2=options.retryTimes)!==null&&_b2!==void 0?_b2:3,"f");const defaultBackoffFactory=__name(()=>new ExponentialBackoff({maxIterations:__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f")}),"defaultBackoffFactory");if(__classPrivateFieldSet$4(this,_HttpAgent_backoffStrategy,options.backoffStrategy||defaultBackoffFactory,"f"),this.host.hostname.endsWith(IC0_SUB_DOMAIN)?this.host.hostname=IC0_DOMAIN:this.host.hostname.endsWith(ICP0_SUB_DOMAIN)?this.host.hostname=ICP0_DOMAIN:this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)&&(this.host.hostname=ICP_API_DOMAIN),options.credentials){const{name,password}=options.credentials;__classPrivateFieldSet$4(this,_HttpAgent_credentials,`${name}${password?":"+password:""}`,"f")}if(__classPrivateFieldSet$4(this,_HttpAgent_identity,Promise.resolve(options.identity||new AnonymousIdentity),"f"),options.ingressExpiryInMinutes&&options.ingressExpiryInMinutes>5)throw new AgentError(`The maximum ingress expiry time is 5 minutes. Provided ingress expiry time is ${options.ingressExpiryInMinutes} minutes.`);if(options.ingressExpiryInMinutes&&options.ingressExpiryInMinutes<=0)throw new AgentError(`Ingress expiry time must be greater than 0. Provided ingress expiry time is ${options.ingressExpiryInMinutes} minutes.`);__classPrivateFieldSet$4(this,_HttpAgent_maxIngressExpiryInMinutes,options.ingressExpiryInMinutes||5,"f"),this.addTransform("update",makeNonceTransform(makeNonce)),options.useQueryNonces&&this.addTransform("query",makeNonceTransform(makeNonce)),options.logToConsole&&this.log.subscribe(log=>{log.level==="error"?console.error(log.message):log.level==="warn"?console.warn(log.message):console.log(log.message)})}get waterMark(){return __classPrivateFieldGet$4(this,_HttpAgent_waterMark,"f")}static createSync(options={}){return new this(Object.assign({},options))}static async create(options={shouldFetchRootKey:!1}){const agent=_HttpAgent.createSync(options),initPromises=[agent.syncTime()];return agent.host.toString()!=="https://icp-api.io"&&options.shouldFetchRootKey&&initPromises.push(agent.fetchRootKey()),await Promise.all(initPromises),agent}static async from(agent){var _a4;try{return"config"in agent?await _HttpAgent.create(agent.config):await _HttpAgent.create({fetch:agent._fetch,fetchOptions:agent._fetchOptions,callOptions:agent._callOptions,host:agent._host.toString(),identity:(_a4=agent._identity)!==null&&_a4!==void 0?_a4:void 0})}catch{throw new AgentError("Failed to create agent from provided agent")}}isLocal(){const hostname=this.host.hostname;return hostname==="127.0.0.1"||hostname.endsWith("127.0.0.1")}addTransform(type,fn,priority=fn.priority||0){if(type==="update"){const i=__classPrivateFieldGet$4(this,_HttpAgent_updatePipeline,"f").findIndex(x=>(x.priority||0)<priority);__classPrivateFieldGet$4(this,_HttpAgent_updatePipeline,"f").splice(i>=0?i:__classPrivateFieldGet$4(this,_HttpAgent_updatePipeline,"f").length,0,Object.assign(fn,{priority}))}else if(type==="query"){const i=__classPrivateFieldGet$4(this,_HttpAgent_queryPipeline,"f").findIndex(x=>(x.priority||0)<priority);__classPrivateFieldGet$4(this,_HttpAgent_queryPipeline,"f").splice(i>=0?i:__classPrivateFieldGet$4(this,_HttpAgent_queryPipeline,"f").length,0,Object.assign(fn,{priority}))}}async getPrincipal(){if(!__classPrivateFieldGet$4(this,_HttpAgent_identity,"f"))throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");return(await __classPrivateFieldGet$4(this,_HttpAgent_identity,"f")).getPrincipal()}async call(canisterId,options,identity){var _a4,_b2;await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_rootKeyGuard).call(this);const callSync=(_a4=options.callSync)!==null&&_a4!==void 0?_a4:!0,id=await(identity!==void 0?await identity:await __classPrivateFieldGet$4(this,_HttpAgent_identity,"f"));if(!id)throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");const canister=Principal$1.from(canisterId),ecid=options.effectiveCanisterId?Principal$1.from(options.effectiveCanisterId):canister,sender=id.getPrincipal()||Principal$1.anonymous();let ingress_expiry=new Expiry(__classPrivateFieldGet$4(this,_HttpAgent_maxIngressExpiryInMinutes,"f")*MINUTE_TO_MSECS);Math.abs(__classPrivateFieldGet$4(this,_HttpAgent_timeDiffMsecs,"f"))>1e3*30&&(ingress_expiry=new Expiry(__classPrivateFieldGet$4(this,_HttpAgent_maxIngressExpiryInMinutes,"f")*MINUTE_TO_MSECS+__classPrivateFieldGet$4(this,_HttpAgent_timeDiffMsecs,"f")));const submit={request_type:SubmitRequestType.Call,canister_id:canister,method_name:options.methodName,arg:options.arg,sender,ingress_expiry};let transformedRequest=await this._transform({request:{body:null,method:"POST",headers:Object.assign({"Content-Type":"application/cbor"},__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f")?{Authorization:"Basic "+btoa(__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f"))}:{})},endpoint:"call",body:submit}),nonce;options?.nonce?nonce=toNonce(options.nonce):transformedRequest.body.nonce?nonce=toNonce(transformedRequest.body.nonce):nonce=void 0,submit.nonce=nonce;function toNonce(buf){return new Uint8Array(buf)}__name(toNonce,"toNonce"),transformedRequest=await id.transformRequest(transformedRequest);const body=encode(transformedRequest.body),backoff2=__classPrivateFieldGet$4(this,_HttpAgent_backoffStrategy,"f").call(this),requestId=requestIdOf(submit);try{const requestSync=__name(()=>(this.log.print(`fetching "/api/v3/canister/${ecid.toText()}/call" with request:`,transformedRequest),__classPrivateFieldGet$4(this,_HttpAgent_fetch,"f").call(this,""+new URL(`/api/v3/canister/${ecid.toText()}/call`,this.host),Object.assign(Object.assign(Object.assign({},__classPrivateFieldGet$4(this,_HttpAgent_callOptions,"f")),transformedRequest.request),{body}))),"requestSync"),requestAsync=__name(()=>(this.log.print(`fetching "/api/v2/canister/${ecid.toText()}/call" with request:`,transformedRequest),__classPrivateFieldGet$4(this,_HttpAgent_fetch,"f").call(this,""+new URL(`/api/v2/canister/${ecid.toText()}/call`,this.host),Object.assign(Object.assign(Object.assign({},__classPrivateFieldGet$4(this,_HttpAgent_callOptions,"f")),transformedRequest.request),{body}))),"requestAsync"),response=await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetry).call(this,{request:callSync?requestSync:requestAsync,backoff:backoff2,tries:0}),responseBuffer=await response.arrayBuffer(),responseBody=response.status===200&&responseBuffer.byteLength>0?decode(responseBuffer):null;if(responseBody&&"certificate"in responseBody){const time=await this.parseTimeFromResponse({certificate:responseBody.certificate});__classPrivateFieldSet$4(this,_HttpAgent_waterMark,time,"f")}return{requestId,response:{ok:response.ok,status:response.status,statusText:response.statusText,body:responseBody,headers:httpHeadersTransform(response.headers)},requestDetails:submit}}catch(error){if(error.message.includes("v3 api not supported."))return this.log.warn("v3 api not supported. Fall back to v2"),this.call(canisterId,Object.assign(Object.assign({},options),{callSync:!1}),identity);const message=`Error while making call: ${(_b2=error.message)!==null&&_b2!==void 0?_b2:String(error)}`,callError=new AgentCallError(message,error,toHex(requestId),toHex(transformedRequest.body.sender_pubkey),toHex(transformedRequest.body.sender_sig),String(transformedRequest.body.content.ingress_expiry._value));throw this.log.error(message,callError),callError}}async query(canisterId,fields,identity){var _a4,_b2,_c,_d;await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_rootKeyGuard).call(this);const backoff2=__classPrivateFieldGet$4(this,_HttpAgent_backoffStrategy,"f").call(this),ecid=fields.effectiveCanisterId?Principal$1.from(fields.effectiveCanisterId):Principal$1.from(canisterId);this.log.print(`ecid ${ecid.toString()}`),this.log.print(`canisterId ${canisterId.toString()}`);let transformedRequest,queryResult;const id=await(identity!==void 0?identity:__classPrivateFieldGet$4(this,_HttpAgent_identity,"f"));if(!id)throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");const canister=Principal$1.from(canisterId),sender=id?.getPrincipal()||Principal$1.anonymous(),request2={request_type:"query",canister_id:canister,method_name:fields.methodName,arg:fields.arg,sender,ingress_expiry:new Expiry(__classPrivateFieldGet$4(this,_HttpAgent_maxIngressExpiryInMinutes,"f")*MINUTE_TO_MSECS)},requestId=requestIdOf(request2);transformedRequest=await this._transform({request:{method:"POST",headers:Object.assign({"Content-Type":"application/cbor"},__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f")?{Authorization:"Basic "+btoa(__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f"))}:{})},endpoint:"read",body:request2}),transformedRequest=await id?.transformRequest(transformedRequest);const body=encode(transformedRequest.body),args={canister:canister.toText(),ecid,transformedRequest,body,requestId,backoff:backoff2,tries:0},makeQuery=__name(async()=>({requestDetails:request2,query:await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetryQuery).call(this,args)}),"makeQuery"),getSubnetStatus=__name(async()=>{if(!__classPrivateFieldGet$4(this,_HttpAgent_verifyQuerySignatures,"f"))return;const subnetStatus=__classPrivateFieldGet$4(this,_HttpAgent_subnetKeys,"f").get(ecid.toString());return subnetStatus||(await this.fetchSubnetKeys(ecid.toString()),__classPrivateFieldGet$4(this,_HttpAgent_subnetKeys,"f").get(ecid.toString()))},"getSubnetStatus");try{const[_queryResult,subnetStatus]=await Promise.all([makeQuery(),getSubnetStatus()]);queryResult=_queryResult;const{requestDetails,query}=queryResult,queryWithDetails=Object.assign(Object.assign({},query),{requestDetails});if(this.log.print("Query response:",queryWithDetails),!__classPrivateFieldGet$4(this,_HttpAgent_verifyQuerySignatures,"f"))return queryWithDetails;try{return __classPrivateFieldGet$4(this,_HttpAgent_verifyQueryResponse,"f").call(this,queryWithDetails,subnetStatus)}catch{this.log.warn("Query response verification failed. Retrying with fresh subnet keys."),__classPrivateFieldGet$4(this,_HttpAgent_subnetKeys,"f").delete(canisterId.toString()),await this.fetchSubnetKeys(ecid.toString());const updatedSubnetStatus=__classPrivateFieldGet$4(this,_HttpAgent_subnetKeys,"f").get(canisterId.toString());if(!updatedSubnetStatus)throw new CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");return __classPrivateFieldGet$4(this,_HttpAgent_verifyQueryResponse,"f").call(this,queryWithDetails,updatedSubnetStatus)}}catch(error){const message=`Error while making call: ${(_a4=error.message)!==null&&_a4!==void 0?_a4:String(error)}`,queryError=new AgentQueryError(message,error,String(requestId),toHex((_b2=transformedRequest?.body)===null||_b2===void 0?void 0:_b2.sender_pubkey),toHex((_c=transformedRequest?.body)===null||_c===void 0?void 0:_c.sender_sig),String((_d=transformedRequest?.body)===null||_d===void 0?void 0:_d.content.ingress_expiry._value));throw this.log.error(message,queryError),queryError}}async createReadStateRequest(fields,identity){await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_rootKeyGuard).call(this);const id=await(identity!==void 0?await identity:await __classPrivateFieldGet$4(this,_HttpAgent_identity,"f"));if(!id)throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");const sender=id?.getPrincipal()||Principal$1.anonymous(),transformedRequest=await this._transform({request:{method:"POST",headers:Object.assign({"Content-Type":"application/cbor"},__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f")?{Authorization:"Basic "+btoa(__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f"))}:{})},endpoint:"read_state",body:{request_type:"read_state",paths:fields.paths,sender,ingress_expiry:new Expiry(__classPrivateFieldGet$4(this,_HttpAgent_maxIngressExpiryInMinutes,"f")*MINUTE_TO_MSECS)}});return id?.transformRequest(transformedRequest)}async readState(canisterId,fields,identity,request2){var _a4,_b2,_c,_d;function getRequestId(fields2){for(const path of fields2.paths){const[pathName,value]=path,request_status=bufFromBufLike$1(new TextEncoder().encode("request_status"));if(bufEquals(pathName,request_status))return value}}__name(getRequestId,"getRequestId");const requestId=getRequestId(fields);await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_rootKeyGuard).call(this);const canister=typeof canisterId=="string"?Principal$1.fromText(canisterId):canisterId,transformedRequest=request2??await this.createReadStateRequest(fields,identity),body=encode(transformedRequest.body);this.log.print(`fetching "/api/v2/canister/${canister}/read_state" with request:`,transformedRequest);const backoff2=__classPrivateFieldGet$4(this,_HttpAgent_backoffStrategy,"f").call(this);try{const response=await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetry).call(this,{request:()=>__classPrivateFieldGet$4(this,_HttpAgent_fetch,"f").call(this,""+new URL(`/api/v2/canister/${canister.toString()}/read_state`,this.host),Object.assign(Object.assign(Object.assign({},__classPrivateFieldGet$4(this,_HttpAgent_fetchOptions,"f")),transformedRequest.request),{body})),backoff:backoff2,tries:0});if(!response.ok)throw new Error(`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${await response.text()}
`);const decodedResponse=decode(await response.arrayBuffer());this.log.print("Read state response:",decodedResponse);const parsedTime=await this.parseTimeFromResponse(decodedResponse);return parsedTime>0&&(this.log.print("Read state response time:",parsedTime),__classPrivateFieldSet$4(this,_HttpAgent_waterMark,parsedTime,"f")),decodedResponse}catch(error){const message=`Caught exception while attempting to read state: ${(_a4=error.message)!==null&&_a4!==void 0?_a4:String(error)}`,readStateError=new AgentReadStateError(message,error,String(requestId),toHex((_b2=transformedRequest?.body)===null||_b2===void 0?void 0:_b2.sender_pubkey),toHex((_c=transformedRequest?.body)===null||_c===void 0?void 0:_c.sender_sig),String((_d=transformedRequest?.body)===null||_d===void 0?void 0:_d.content.ingress_expiry._value));throw this.log.error(message,readStateError),readStateError}}async parseTimeFromResponse(response){let tree;if(response.certificate){const decoded=decode(response.certificate);if(decoded&&"tree"in decoded)tree=decoded.tree;else throw new Error("Could not decode time from response");const timeLookup=lookup_path(["time"],tree);if(timeLookup.status!==LookupStatus.Found)throw new Error("Time was not found in the response or was not in its expected format.");if(!(timeLookup.value instanceof ArrayBuffer)&&!ArrayBuffer.isView(timeLookup))throw new Error("Time was not found in the response or was not in its expected format.");const date=decodeTime(bufFromBufLike$1(timeLookup.value));return this.log.print("Time from response:",date),this.log.print("Time from response in milliseconds:",Number(date)),Number(date)}else this.log.warn("No certificate found in response");return 0}async syncTime(canisterId){await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_rootKeyGuard).call(this);const CanisterStatus=await __vitePreload(()=>Promise.resolve().then(()=>index$2),void 0),callTime=Date.now();try{canisterId||this.log.print("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");const anonymousAgent=_HttpAgent.createSync({identity:new AnonymousIdentity,host:this.host.toString(),fetch:__classPrivateFieldGet$4(this,_HttpAgent_fetch,"f"),retryTimes:0}),replicaTime=(await CanisterStatus.request({canisterId:canisterId??Principal$1.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),agent:anonymousAgent,paths:["time"]})).get("time");replicaTime&&(__classPrivateFieldSet$4(this,_HttpAgent_timeDiffMsecs,Number(replicaTime)-Number(callTime),"f"),this.log.notify({message:`Syncing time: offset of ${__classPrivateFieldGet$4(this,_HttpAgent_timeDiffMsecs,"f")}`,level:"info"}))}catch(error){this.log.error("Caught exception while attempting to sync time",error)}}async status(){const headers=__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f")?{Authorization:"Basic "+btoa(__classPrivateFieldGet$4(this,_HttpAgent_credentials,"f"))}:{};this.log.print('fetching "/api/v2/status"');const backoff2=__classPrivateFieldGet$4(this,_HttpAgent_backoffStrategy,"f").call(this),response=await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetry).call(this,{backoff:backoff2,request:()=>__classPrivateFieldGet$4(this,_HttpAgent_fetch,"f").call(this,""+new URL("/api/v2/status",this.host),Object.assign({headers},__classPrivateFieldGet$4(this,_HttpAgent_fetchOptions,"f"))),tries:0});return decode(await response.arrayBuffer())}async fetchRootKey(){let result;return __classPrivateFieldGet$4(this,_HttpAgent_rootKeyPromise,"f")?result=await __classPrivateFieldGet$4(this,_HttpAgent_rootKeyPromise,"f"):(__classPrivateFieldSet$4(this,_HttpAgent_rootKeyPromise,new Promise((resolve,reject)=>{this.status().then(value=>{const rootKey=value.root_key;this.rootKey=rootKey,resolve(rootKey)}).catch(reject)}),"f"),result=await __classPrivateFieldGet$4(this,_HttpAgent_rootKeyPromise,"f")),__classPrivateFieldSet$4(this,_HttpAgent_rootKeyPromise,null,"f"),result}invalidateIdentity(){__classPrivateFieldSet$4(this,_HttpAgent_identity,null,"f")}replaceIdentity(identity){__classPrivateFieldSet$4(this,_HttpAgent_identity,Promise.resolve(identity),"f")}async fetchSubnetKeys(canisterId){await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_rootKeyGuard).call(this);const effectiveCanisterId=Principal$1.from(canisterId),subnetResponse=(await request({canisterId:effectiveCanisterId,paths:["subnet"],agent:this})).get("subnet");if(subnetResponse&&typeof subnetResponse=="object"&&"nodeKeys"in subnetResponse)return __classPrivateFieldGet$4(this,_HttpAgent_subnetKeys,"f").set(effectiveCanisterId.toText(),subnetResponse),subnetResponse}_transform(request2){let p=Promise.resolve(request2);if(request2.endpoint==="call")for(const fn of __classPrivateFieldGet$4(this,_HttpAgent_updatePipeline,"f"))p=p.then(r=>fn(r).then(r2=>r2||r));else for(const fn of __classPrivateFieldGet$4(this,_HttpAgent_queryPipeline,"f"))p=p.then(r=>fn(r).then(r2=>r2||r));return p}};__name(_HttpAgent,"HttpAgent");let HttpAgent=_HttpAgent;_HttpAgent_rootKeyPromise=new WeakMap,_HttpAgent_shouldFetchRootKey=new WeakMap,_HttpAgent_identity=new WeakMap,_HttpAgent_fetch=new WeakMap,_HttpAgent_fetchOptions=new WeakMap,_HttpAgent_callOptions=new WeakMap,_HttpAgent_timeDiffMsecs=new WeakMap,_HttpAgent_credentials=new WeakMap,_HttpAgent_retryTimes=new WeakMap,_HttpAgent_backoffStrategy=new WeakMap,_HttpAgent_maxIngressExpiryInMinutes=new WeakMap,_HttpAgent_waterMark=new WeakMap,_HttpAgent_queryPipeline=new WeakMap,_HttpAgent_updatePipeline=new WeakMap,_HttpAgent_subnetKeys=new WeakMap,_HttpAgent_verifyQuerySignatures=new WeakMap,_HttpAgent_verifyQueryResponse=new WeakMap,_HttpAgent_instances=new WeakSet,_HttpAgent_requestAndRetryQuery=__name(async function _HttpAgent_requestAndRetryQuery2(args){var _a4,_b2;const{ecid,transformedRequest,body,requestId,backoff:backoff2,tries}=args,delay=tries===0?0:backoff2.next();if(this.log.print(`fetching "/api/v2/canister/${ecid.toString()}/query" with tries:`,{tries,backoff:backoff2,delay}),delay===null)throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);delay>0&&await new Promise(resolve=>setTimeout(resolve,delay));let response;try{this.log.print(`fetching "/api/v2/canister/${ecid.toString()}/query" with request:`,transformedRequest);const fetchResponse=await __classPrivateFieldGet$4(this,_HttpAgent_fetch,"f").call(this,""+new URL(`/api/v2/canister/${ecid.toString()}/query`,this.host),Object.assign(Object.assign(Object.assign({},__classPrivateFieldGet$4(this,_HttpAgent_fetchOptions,"f")),transformedRequest.request),{body}));if(fetchResponse.status===200){const queryResponse=decode(await fetchResponse.arrayBuffer());response=Object.assign(Object.assign({},queryResponse),{httpDetails:{ok:fetchResponse.ok,status:fetchResponse.status,statusText:fetchResponse.statusText,headers:httpHeadersTransform(fetchResponse.headers)},requestId})}else throw new AgentHTTPResponseError(`Gateway returned an error:
  Code: ${fetchResponse.status} (${fetchResponse.statusText})
  Body: ${await fetchResponse.text()}
`,{ok:fetchResponse.ok,status:fetchResponse.status,statusText:fetchResponse.statusText,headers:httpHeadersTransform(fetchResponse.headers)})}catch(error){if(tries<__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f"))return this.log.warn(`Caught exception while attempting to make query:
  ${error}
  Retrying query.`),await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetryQuery2).call(this,Object.assign(Object.assign({},args),{tries:tries+1}));throw error}const timestamp=(_b2=(_a4=response.signatures)===null||_a4===void 0?void 0:_a4[0])===null||_b2===void 0?void 0:_b2.timestamp;if(!__classPrivateFieldGet$4(this,_HttpAgent_verifyQuerySignatures,"f"))return response;if(!timestamp)throw new Error("Timestamp not found in query response. This suggests a malformed or malicious response.");const timeStampInMs=Number(BigInt(timestamp)/BigInt(1e6));if(this.log.print("watermark and timestamp",{waterMark:this.waterMark,timestamp:timeStampInMs}),Number(this.waterMark)>timeStampInMs){const error=new AgentError("Timestamp is below the watermark. Retrying query.");if(this.log.error("Timestamp is below",error,{timestamp,waterMark:this.waterMark}),tries<__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f"))return await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetryQuery2).call(this,Object.assign(Object.assign({},args),{tries:tries+1}));throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`)}return response},"_HttpAgent_requestAndRetryQuery"),_HttpAgent_requestAndRetry=__name(async function _HttpAgent_requestAndRetry2(args){const{request:request2,backoff:backoff2,tries}=args,delay=tries===0?0:backoff2.next();if(delay===null)throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);delay>0&&await new Promise(resolve=>setTimeout(resolve,delay));let response;try{response=await request2()}catch(error){if(__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f")>tries)return this.log.warn(`Caught exception while attempting to make request:
  ${error}
  Retrying request.`),await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetry2).call(this,{request:request2,backoff:backoff2,tries:tries+1});throw error}if(response.ok)return response;const responseText=await response.clone().text(),errorMessage=`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${responseText}
`;if(response.status===404&&response.url.includes("api/v3"))throw new AgentHTTPResponseError("v3 api not supported. Fall back to v2",{ok:response.ok,status:response.status,statusText:response.statusText,headers:httpHeadersTransform(response.headers)});if(tries<__classPrivateFieldGet$4(this,_HttpAgent_retryTimes,"f"))return await __classPrivateFieldGet$4(this,_HttpAgent_instances,"m",_HttpAgent_requestAndRetry2).call(this,{request:request2,backoff:backoff2,tries:tries+1});throw new AgentHTTPResponseError(errorMessage,{ok:response.ok,status:response.status,statusText:response.statusText,headers:httpHeadersTransform(response.headers)})},"_HttpAgent_requestAndRetry"),_HttpAgent_rootKeyGuard=__name(async function(){if(!this.rootKey)if(this.rootKey===null&&__classPrivateFieldGet$4(this,_HttpAgent_shouldFetchRootKey,"f"))await this.fetchRootKey();else throw new AgentError(`Invalid root key detected. The root key for this agent is ${this.rootKey} and the shouldFetchRootKey value is set to ${__classPrivateFieldGet$4(this,_HttpAgent_shouldFetchRootKey,"f")}. The root key should only be unknown if you are in local development. Otherwise you should avoid fetching and use the default IC Root Key or the known root key of your environment.`)},"_HttpAgent_rootKeyGuard");var ProxyMessageKind;(function(ProxyMessageKind2){ProxyMessageKind2.Error="err",ProxyMessageKind2.GetPrincipal="gp",ProxyMessageKind2.GetPrincipalResponse="gpr",ProxyMessageKind2.Query="q",ProxyMessageKind2.QueryResponse="qr",ProxyMessageKind2.Call="c",ProxyMessageKind2.CallResponse="cr",ProxyMessageKind2.ReadState="rs",ProxyMessageKind2.ReadStateResponse="rsr",ProxyMessageKind2.Status="s",ProxyMessageKind2.StatusResponse="sr"})(ProxyMessageKind||(ProxyMessageKind={}));const _ProxyStubAgent=class _ProxyStubAgent{constructor(_frontend,_agent){this._frontend=_frontend,this._agent=_agent}onmessage(msg){switch(msg.type){case ProxyMessageKind.GetPrincipal:this._agent.getPrincipal().then(response=>{this._frontend({id:msg.id,type:ProxyMessageKind.GetPrincipalResponse,response:response.toText()})});break;case ProxyMessageKind.Query:this._agent.query(...msg.args).then(response=>{this._frontend({id:msg.id,type:ProxyMessageKind.QueryResponse,response})});break;case ProxyMessageKind.Call:this._agent.call(...msg.args).then(response=>{this._frontend({id:msg.id,type:ProxyMessageKind.CallResponse,response})});break;case ProxyMessageKind.ReadState:this._agent.readState(...msg.args).then(response=>{this._frontend({id:msg.id,type:ProxyMessageKind.ReadStateResponse,response})});break;case ProxyMessageKind.Status:this._agent.status().then(response=>{this._frontend({id:msg.id,type:ProxyMessageKind.StatusResponse,response})});break;default:throw new Error(`Invalid message received: ${JSON.stringify(msg)}`)}}};__name(_ProxyStubAgent,"ProxyStubAgent");let ProxyStubAgent=_ProxyStubAgent;const _ProxyAgent=class _ProxyAgent{constructor(_backend){this._backend=_backend,this._nextId=0,this._pendingCalls=new Map,this.rootKey=null}onmessage(msg){const id=msg.id,maybePromise=this._pendingCalls.get(id);if(!maybePromise)throw new Error("A proxy get the same message twice...");this._pendingCalls.delete(id);const[resolve,reject]=maybePromise;switch(msg.type){case ProxyMessageKind.Error:return reject(msg.error);case ProxyMessageKind.GetPrincipalResponse:case ProxyMessageKind.CallResponse:case ProxyMessageKind.QueryResponse:case ProxyMessageKind.ReadStateResponse:case ProxyMessageKind.StatusResponse:return resolve(msg.response);default:throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`)}}async getPrincipal(){return this._sendAndWait({id:this._nextId++,type:ProxyMessageKind.GetPrincipal}).then(principal=>{if(typeof principal!="string")throw new Error("Invalid principal received.");return Principal$1.fromText(principal)})}readState(canisterId,fields){return this._sendAndWait({id:this._nextId++,type:ProxyMessageKind.ReadState,args:[canisterId.toString(),fields]})}call(canisterId,fields){return this._sendAndWait({id:this._nextId++,type:ProxyMessageKind.Call,args:[canisterId.toString(),fields]})}status(){return this._sendAndWait({id:this._nextId++,type:ProxyMessageKind.Status})}query(canisterId,fields){return this._sendAndWait({id:this._nextId++,type:ProxyMessageKind.Query,args:[canisterId.toString(),fields]})}async _sendAndWait(msg){return new Promise((resolve,reject)=>{this._pendingCalls.set(msg.id,[resolve,reject]),this._backend(msg)})}async fetchRootKey(){const rootKey=(await this.status()).root_key;return this.rootKey=rootKey,rootKey}};__name(_ProxyAgent,"ProxyAgent");let ProxyAgent=_ProxyAgent;function getDefaultAgent(){const agent=typeof window>"u"?typeof globalThis>"u"?typeof self>"u"?void 0:self.ic.agent:globalThis.ic.agent:window.ic.agent;if(!agent)throw new Error("No Agent could be found.");return agent}__name(getDefaultAgent,"getDefaultAgent");const FIVE_MINUTES_IN_MSEC=5*60*1e3;function defaultStrategy(){return chain(conditionalDelay(once(),1e3),backoff(1e3,1.2),timeout(FIVE_MINUTES_IN_MSEC))}__name(defaultStrategy,"defaultStrategy");function once(){let first=!0;return async()=>first?(first=!1,!0):!1}__name(once,"once");function conditionalDelay(condition,timeInMsec){return async(canisterId,requestId,status)=>{if(await condition(canisterId,requestId,status))return new Promise(resolve=>setTimeout(resolve,timeInMsec))}}__name(conditionalDelay,"conditionalDelay");function maxAttempts(count){let attempts=count;return async(canisterId,requestId,status)=>{if(--attempts<=0)throw new Error(`Failed to retrieve a reply for request after ${count} attempts:
  Request ID: ${toHex(requestId)}
  Request status: ${status}
`)}}__name(maxAttempts,"maxAttempts");function throttle(throttleInMsec){return()=>new Promise(resolve=>setTimeout(resolve,throttleInMsec))}__name(throttle,"throttle");function timeout(timeInMsec){const end=Date.now()+timeInMsec;return async(canisterId,requestId,status)=>{if(Date.now()>end)throw new Error(`Request timed out after ${timeInMsec} msec:
  Request ID: ${toHex(requestId)}
  Request status: ${status}
`)}}__name(timeout,"timeout");function backoff(startingThrottleInMsec,backoffFactor){let currentThrottling=startingThrottleInMsec;return()=>new Promise(resolve=>setTimeout(()=>{currentThrottling*=backoffFactor,resolve()},currentThrottling))}__name(backoff,"backoff");function chain(...strategies){return async(canisterId,requestId,status)=>{for(const a of strategies)await a(canisterId,requestId,status)}}__name(chain,"chain");const strategy=Object.freeze(Object.defineProperty({__proto__:null,backoff,chain,conditionalDelay,defaultStrategy,maxAttempts,once,throttle,timeout},Symbol.toStringTag,{value:"Module"}));async function pollForResponse(agent,canisterId,requestId,strategy2=defaultStrategy(),request2,blsVerify2){var _a4;const path=[new TextEncoder().encode("request_status"),requestId],currentRequest=request2??await((_a4=agent.createReadStateRequest)===null||_a4===void 0?void 0:_a4.call(agent,{paths:[path]})),state=await agent.readState(canisterId,{paths:[path]},void 0,currentRequest);if(agent.rootKey==null)throw new Error("Agent root key not initialized before polling");const cert=await Certificate.create({certificate:state.certificate,rootKey:agent.rootKey,canisterId,blsVerify:blsVerify2}),maybeBuf=lookupResultToBuffer(cert.lookup([...path,new TextEncoder().encode("status")]));let status;switch(typeof maybeBuf>"u"?status=RequestStatusResponseStatus.Unknown:status=new TextDecoder().decode(maybeBuf),status){case RequestStatusResponseStatus.Replied:return{reply:lookupResultToBuffer(cert.lookup([...path,"reply"])),certificate:cert};case RequestStatusResponseStatus.Received:case RequestStatusResponseStatus.Unknown:case RequestStatusResponseStatus.Processing:return await strategy2(canisterId,requestId,status),pollForResponse(agent,canisterId,requestId,strategy2,currentRequest,blsVerify2);case RequestStatusResponseStatus.Rejected:{const rejectCode=new Uint8Array(lookupResultToBuffer(cert.lookup([...path,"reject_code"])))[0],rejectMessage=new TextDecoder().decode(lookupResultToBuffer(cert.lookup([...path,"reject_message"])));throw new Error(`Call was rejected:
  Request ID: ${toHex(requestId)}
  Reject code: ${rejectCode}
  Reject text: ${rejectMessage}
`)}case RequestStatusResponseStatus.Done:throw new Error(`Call was marked as done but we never saw the reply:
  Request ID: ${toHex(requestId)}
`)}throw new Error("unreachable")}__name(pollForResponse,"pollForResponse");const index$1=Object.freeze(Object.defineProperty({__proto__:null,defaultStrategy,pollForResponse,strategy},Symbol.toStringTag,{value:"Module"})),managementCanisterIdl=__name(({IDL:IDL2})=>{const bitcoin_network=IDL2.Variant({mainnet:IDL2.Null,testnet:IDL2.Null}),bitcoin_address=IDL2.Text,bitcoin_get_balance_args=IDL2.Record({network:bitcoin_network,address:bitcoin_address,min_confirmations:IDL2.Opt(IDL2.Nat32)}),satoshi=IDL2.Nat64,bitcoin_get_balance_result=satoshi,bitcoin_block_height=IDL2.Nat32,bitcoin_get_block_headers_args=IDL2.Record({start_height:bitcoin_block_height,end_height:IDL2.Opt(bitcoin_block_height),network:bitcoin_network}),bitcoin_block_header=IDL2.Vec(IDL2.Nat8),bitcoin_get_block_headers_result=IDL2.Record({tip_height:bitcoin_block_height,block_headers:IDL2.Vec(bitcoin_block_header)}),bitcoin_get_current_fee_percentiles_args=IDL2.Record({network:bitcoin_network}),millisatoshi_per_byte=IDL2.Nat64,bitcoin_get_current_fee_percentiles_result=IDL2.Vec(millisatoshi_per_byte),bitcoin_get_utxos_args=IDL2.Record({network:bitcoin_network,filter:IDL2.Opt(IDL2.Variant({page:IDL2.Vec(IDL2.Nat8),min_confirmations:IDL2.Nat32})),address:bitcoin_address}),bitcoin_block_hash=IDL2.Vec(IDL2.Nat8),outpoint=IDL2.Record({txid:IDL2.Vec(IDL2.Nat8),vout:IDL2.Nat32}),utxo=IDL2.Record({height:IDL2.Nat32,value:satoshi,outpoint}),bitcoin_get_utxos_result=IDL2.Record({next_page:IDL2.Opt(IDL2.Vec(IDL2.Nat8)),tip_height:bitcoin_block_height,tip_block_hash:bitcoin_block_hash,utxos:IDL2.Vec(utxo)}),bitcoin_send_transaction_args=IDL2.Record({transaction:IDL2.Vec(IDL2.Nat8),network:bitcoin_network}),canister_id=IDL2.Principal,canister_info_args=IDL2.Record({canister_id,num_requested_changes:IDL2.Opt(IDL2.Nat64)}),change_origin=IDL2.Variant({from_user:IDL2.Record({user_id:IDL2.Principal}),from_canister:IDL2.Record({canister_version:IDL2.Opt(IDL2.Nat64),canister_id:IDL2.Principal})}),snapshot_id=IDL2.Vec(IDL2.Nat8),change_details=IDL2.Variant({creation:IDL2.Record({controllers:IDL2.Vec(IDL2.Principal)}),code_deployment:IDL2.Record({mode:IDL2.Variant({reinstall:IDL2.Null,upgrade:IDL2.Null,install:IDL2.Null}),module_hash:IDL2.Vec(IDL2.Nat8)}),load_snapshot:IDL2.Record({canister_version:IDL2.Nat64,taken_at_timestamp:IDL2.Nat64,snapshot_id}),controllers_change:IDL2.Record({controllers:IDL2.Vec(IDL2.Principal)}),code_uninstall:IDL2.Null}),change=IDL2.Record({timestamp_nanos:IDL2.Nat64,canister_version:IDL2.Nat64,origin:change_origin,details:change_details}),canister_info_result=IDL2.Record({controllers:IDL2.Vec(IDL2.Principal),module_hash:IDL2.Opt(IDL2.Vec(IDL2.Nat8)),recent_changes:IDL2.Vec(change),total_num_changes:IDL2.Nat64}),canister_status_args=IDL2.Record({canister_id}),log_visibility=IDL2.Variant({controllers:IDL2.Null,public:IDL2.Null,allowed_viewers:IDL2.Vec(IDL2.Principal)}),definite_canister_settings=IDL2.Record({freezing_threshold:IDL2.Nat,controllers:IDL2.Vec(IDL2.Principal),reserved_cycles_limit:IDL2.Nat,log_visibility,wasm_memory_limit:IDL2.Nat,memory_allocation:IDL2.Nat,compute_allocation:IDL2.Nat}),canister_status_result=IDL2.Record({status:IDL2.Variant({stopped:IDL2.Null,stopping:IDL2.Null,running:IDL2.Null}),memory_size:IDL2.Nat,cycles:IDL2.Nat,settings:definite_canister_settings,query_stats:IDL2.Record({response_payload_bytes_total:IDL2.Nat,num_instructions_total:IDL2.Nat,num_calls_total:IDL2.Nat,request_payload_bytes_total:IDL2.Nat}),idle_cycles_burned_per_day:IDL2.Nat,module_hash:IDL2.Opt(IDL2.Vec(IDL2.Nat8)),reserved_cycles:IDL2.Nat}),clear_chunk_store_args=IDL2.Record({canister_id}),canister_settings=IDL2.Record({freezing_threshold:IDL2.Opt(IDL2.Nat),controllers:IDL2.Opt(IDL2.Vec(IDL2.Principal)),reserved_cycles_limit:IDL2.Opt(IDL2.Nat),log_visibility:IDL2.Opt(log_visibility),wasm_memory_limit:IDL2.Opt(IDL2.Nat),memory_allocation:IDL2.Opt(IDL2.Nat),compute_allocation:IDL2.Opt(IDL2.Nat)}),create_canister_args=IDL2.Record({settings:IDL2.Opt(canister_settings),sender_canister_version:IDL2.Opt(IDL2.Nat64)}),create_canister_result=IDL2.Record({canister_id}),delete_canister_args=IDL2.Record({canister_id}),delete_canister_snapshot_args=IDL2.Record({canister_id,snapshot_id}),deposit_cycles_args=IDL2.Record({canister_id}),ecdsa_curve=IDL2.Variant({secp256k1:IDL2.Null}),ecdsa_public_key_args=IDL2.Record({key_id:IDL2.Record({name:IDL2.Text,curve:ecdsa_curve}),canister_id:IDL2.Opt(canister_id),derivation_path:IDL2.Vec(IDL2.Vec(IDL2.Nat8))}),ecdsa_public_key_result=IDL2.Record({public_key:IDL2.Vec(IDL2.Nat8),chain_code:IDL2.Vec(IDL2.Nat8)}),fetch_canister_logs_args=IDL2.Record({canister_id}),canister_log_record=IDL2.Record({idx:IDL2.Nat64,timestamp_nanos:IDL2.Nat64,content:IDL2.Vec(IDL2.Nat8)}),fetch_canister_logs_result=IDL2.Record({canister_log_records:IDL2.Vec(canister_log_record)}),http_header=IDL2.Record({value:IDL2.Text,name:IDL2.Text}),http_request_result=IDL2.Record({status:IDL2.Nat,body:IDL2.Vec(IDL2.Nat8),headers:IDL2.Vec(http_header)}),http_request_args=IDL2.Record({url:IDL2.Text,method:IDL2.Variant({get:IDL2.Null,head:IDL2.Null,post:IDL2.Null}),max_response_bytes:IDL2.Opt(IDL2.Nat64),body:IDL2.Opt(IDL2.Vec(IDL2.Nat8)),transform:IDL2.Opt(IDL2.Record({function:IDL2.Func([IDL2.Record({context:IDL2.Vec(IDL2.Nat8),response:http_request_result})],[http_request_result],["query"]),context:IDL2.Vec(IDL2.Nat8)})),headers:IDL2.Vec(http_header)}),canister_install_mode=IDL2.Variant({reinstall:IDL2.Null,upgrade:IDL2.Opt(IDL2.Record({wasm_memory_persistence:IDL2.Opt(IDL2.Variant({keep:IDL2.Null,replace:IDL2.Null})),skip_pre_upgrade:IDL2.Opt(IDL2.Bool)})),install:IDL2.Null}),chunk_hash=IDL2.Record({hash:IDL2.Vec(IDL2.Nat8)}),install_chunked_code_args=IDL2.Record({arg:IDL2.Vec(IDL2.Nat8),wasm_module_hash:IDL2.Vec(IDL2.Nat8),mode:canister_install_mode,chunk_hashes_list:IDL2.Vec(chunk_hash),target_canister:canister_id,store_canister:IDL2.Opt(canister_id),sender_canister_version:IDL2.Opt(IDL2.Nat64)}),wasm_module=IDL2.Vec(IDL2.Nat8),install_code_args=IDL2.Record({arg:IDL2.Vec(IDL2.Nat8),wasm_module,mode:canister_install_mode,canister_id,sender_canister_version:IDL2.Opt(IDL2.Nat64)}),list_canister_snapshots_args=IDL2.Record({canister_id}),snapshot=IDL2.Record({id:snapshot_id,total_size:IDL2.Nat64,taken_at_timestamp:IDL2.Nat64}),list_canister_snapshots_result=IDL2.Vec(snapshot),load_canister_snapshot_args=IDL2.Record({canister_id,sender_canister_version:IDL2.Opt(IDL2.Nat64),snapshot_id}),node_metrics_history_args=IDL2.Record({start_at_timestamp_nanos:IDL2.Nat64,subnet_id:IDL2.Principal}),node_metrics=IDL2.Record({num_block_failures_total:IDL2.Nat64,node_id:IDL2.Principal,num_blocks_proposed_total:IDL2.Nat64}),node_metrics_history_result=IDL2.Vec(IDL2.Record({timestamp_nanos:IDL2.Nat64,node_metrics:IDL2.Vec(node_metrics)})),provisional_create_canister_with_cycles_args=IDL2.Record({settings:IDL2.Opt(canister_settings),specified_id:IDL2.Opt(canister_id),amount:IDL2.Opt(IDL2.Nat),sender_canister_version:IDL2.Opt(IDL2.Nat64)}),provisional_create_canister_with_cycles_result=IDL2.Record({canister_id}),provisional_top_up_canister_args=IDL2.Record({canister_id,amount:IDL2.Nat}),raw_rand_result=IDL2.Vec(IDL2.Nat8),schnorr_algorithm=IDL2.Variant({ed25519:IDL2.Null,bip340secp256k1:IDL2.Null}),schnorr_public_key_args=IDL2.Record({key_id:IDL2.Record({algorithm:schnorr_algorithm,name:IDL2.Text}),canister_id:IDL2.Opt(canister_id),derivation_path:IDL2.Vec(IDL2.Vec(IDL2.Nat8))}),schnorr_public_key_result=IDL2.Record({public_key:IDL2.Vec(IDL2.Nat8),chain_code:IDL2.Vec(IDL2.Nat8)}),sign_with_ecdsa_args=IDL2.Record({key_id:IDL2.Record({name:IDL2.Text,curve:ecdsa_curve}),derivation_path:IDL2.Vec(IDL2.Vec(IDL2.Nat8)),message_hash:IDL2.Vec(IDL2.Nat8)}),sign_with_ecdsa_result=IDL2.Record({signature:IDL2.Vec(IDL2.Nat8)}),schnorr_aux=IDL2.Variant({bip341:IDL2.Record({merkle_root_hash:IDL2.Vec(IDL2.Nat8)})}),sign_with_schnorr_args=IDL2.Record({aux:IDL2.Opt(schnorr_aux),key_id:IDL2.Record({algorithm:schnorr_algorithm,name:IDL2.Text}),derivation_path:IDL2.Vec(IDL2.Vec(IDL2.Nat8)),message:IDL2.Vec(IDL2.Nat8)}),sign_with_schnorr_result=IDL2.Record({signature:IDL2.Vec(IDL2.Nat8)}),start_canister_args=IDL2.Record({canister_id}),stop_canister_args=IDL2.Record({canister_id}),stored_chunks_args=IDL2.Record({canister_id}),stored_chunks_result=IDL2.Vec(chunk_hash),subnet_info_args=IDL2.Record({subnet_id:IDL2.Principal}),subnet_info_result=IDL2.Record({replica_version:IDL2.Text}),take_canister_snapshot_args=IDL2.Record({replace_snapshot:IDL2.Opt(snapshot_id),canister_id}),take_canister_snapshot_result=snapshot,uninstall_code_args=IDL2.Record({canister_id,sender_canister_version:IDL2.Opt(IDL2.Nat64)}),update_settings_args=IDL2.Record({canister_id:IDL2.Principal,settings:canister_settings,sender_canister_version:IDL2.Opt(IDL2.Nat64)}),upload_chunk_args=IDL2.Record({chunk:IDL2.Vec(IDL2.Nat8),canister_id:IDL2.Principal}),upload_chunk_result=chunk_hash;return IDL2.Service({bitcoin_get_balance:IDL2.Func([bitcoin_get_balance_args],[bitcoin_get_balance_result],[]),bitcoin_get_block_headers:IDL2.Func([bitcoin_get_block_headers_args],[bitcoin_get_block_headers_result],[]),bitcoin_get_current_fee_percentiles:IDL2.Func([bitcoin_get_current_fee_percentiles_args],[bitcoin_get_current_fee_percentiles_result],[]),bitcoin_get_utxos:IDL2.Func([bitcoin_get_utxos_args],[bitcoin_get_utxos_result],[]),bitcoin_send_transaction:IDL2.Func([bitcoin_send_transaction_args],[],[]),canister_info:IDL2.Func([canister_info_args],[canister_info_result],[]),canister_status:IDL2.Func([canister_status_args],[canister_status_result],[]),clear_chunk_store:IDL2.Func([clear_chunk_store_args],[],[]),create_canister:IDL2.Func([create_canister_args],[create_canister_result],[]),delete_canister:IDL2.Func([delete_canister_args],[],[]),delete_canister_snapshot:IDL2.Func([delete_canister_snapshot_args],[],[]),deposit_cycles:IDL2.Func([deposit_cycles_args],[],[]),ecdsa_public_key:IDL2.Func([ecdsa_public_key_args],[ecdsa_public_key_result],[]),fetch_canister_logs:IDL2.Func([fetch_canister_logs_args],[fetch_canister_logs_result],["query"]),http_request:IDL2.Func([http_request_args],[http_request_result],[]),install_chunked_code:IDL2.Func([install_chunked_code_args],[],[]),install_code:IDL2.Func([install_code_args],[],[]),list_canister_snapshots:IDL2.Func([list_canister_snapshots_args],[list_canister_snapshots_result],[]),load_canister_snapshot:IDL2.Func([load_canister_snapshot_args],[],[]),node_metrics_history:IDL2.Func([node_metrics_history_args],[node_metrics_history_result],[]),provisional_create_canister_with_cycles:IDL2.Func([provisional_create_canister_with_cycles_args],[provisional_create_canister_with_cycles_result],[]),provisional_top_up_canister:IDL2.Func([provisional_top_up_canister_args],[],[]),raw_rand:IDL2.Func([],[raw_rand_result],[]),schnorr_public_key:IDL2.Func([schnorr_public_key_args],[schnorr_public_key_result],[]),sign_with_ecdsa:IDL2.Func([sign_with_ecdsa_args],[sign_with_ecdsa_result],[]),sign_with_schnorr:IDL2.Func([sign_with_schnorr_args],[sign_with_schnorr_result],[]),start_canister:IDL2.Func([start_canister_args],[],[]),stop_canister:IDL2.Func([stop_canister_args],[],[]),stored_chunks:IDL2.Func([stored_chunks_args],[stored_chunks_result],[]),subnet_info:IDL2.Func([subnet_info_args],[subnet_info_result],[]),take_canister_snapshot:IDL2.Func([take_canister_snapshot_args],[take_canister_snapshot_result],[]),uninstall_code:IDL2.Func([uninstall_code_args],[],[]),update_settings:IDL2.Func([update_settings_args],[],[]),upload_chunk:IDL2.Func([upload_chunk_args],[upload_chunk_result],[])})},"managementCanisterIdl"),_ActorCallError=class _ActorCallError extends AgentError{constructor(canisterId,methodName,type,props){super(["Call failed:",`  Canister: ${canisterId.toText()}`,`  Method: ${methodName} (${type})`,...Object.getOwnPropertyNames(props).map(n=>`  "${n}": ${JSON.stringify(props[n])}`)].join(`
`)),this.canisterId=canisterId,this.methodName=methodName,this.type=type,this.props=props}};__name(_ActorCallError,"ActorCallError");let ActorCallError=_ActorCallError;const _QueryCallRejectedError=class _QueryCallRejectedError extends ActorCallError{constructor(canisterId,methodName,result){var _a4;super(canisterId,methodName,"query",{Status:result.status,Code:(_a4=ReplicaRejectCode[result.reject_code])!==null&&_a4!==void 0?_a4:`Unknown Code "${result.reject_code}"`,Message:result.reject_message}),this.result=result}};__name(_QueryCallRejectedError,"QueryCallRejectedError");let QueryCallRejectedError=_QueryCallRejectedError;const _UpdateCallRejectedError=class _UpdateCallRejectedError extends ActorCallError{constructor(canisterId,methodName,requestId,response,reject_code,reject_message,error_code){super(canisterId,methodName,"update",Object.assign({"Request ID":toHex(requestId)},response.body?Object.assign(Object.assign({},error_code?{"Error code":error_code}:{}),{"Reject code":String(reject_code),"Reject message":reject_message}):{"HTTP status code":response.status.toString(),"HTTP status text":response.statusText})),this.requestId=requestId,this.response=response,this.reject_code=reject_code,this.reject_message=reject_message,this.error_code=error_code}};__name(_UpdateCallRejectedError,"UpdateCallRejectedError");let UpdateCallRejectedError=_UpdateCallRejectedError;const metadataSymbol=Symbol.for("ic-agent-metadata"),_Actor=class _Actor{constructor(metadata){this[metadataSymbol]=Object.freeze(metadata)}static agentOf(actor){return actor[metadataSymbol].config.agent}static interfaceOf(actor){return actor[metadataSymbol].service}static canisterIdOf(actor){return Principal$1.from(actor[metadataSymbol].config.canisterId)}static async install(fields,config){const mode=fields.mode===void 0?{install:null}:fields.mode,arg=fields.arg?[...new Uint8Array(fields.arg)]:[],wasmModule=[...new Uint8Array(fields.module)],canisterId=typeof config.canisterId=="string"?Principal$1.fromText(config.canisterId):config.canisterId;await getManagementCanister(config).install_code({mode,arg,wasm_module:wasmModule,canister_id:canisterId,sender_canister_version:[]})}static async createCanister(config,settings){function settingsToCanisterSettings(settings2){return[{controllers:settings2.controllers?[settings2.controllers]:[],compute_allocation:settings2.compute_allocation?[settings2.compute_allocation]:[],freezing_threshold:settings2.freezing_threshold?[settings2.freezing_threshold]:[],memory_allocation:settings2.memory_allocation?[settings2.memory_allocation]:[],reserved_cycles_limit:[],log_visibility:[],wasm_memory_limit:[]}]}__name(settingsToCanisterSettings,"settingsToCanisterSettings");const{canister_id:canisterId}=await getManagementCanister(config||{}).provisional_create_canister_with_cycles({amount:[],settings:settingsToCanisterSettings(settings||{}),specified_id:[],sender_canister_version:[]});return canisterId}static async createAndInstallCanister(interfaceFactory,fields,config){const canisterId=await this.createCanister(config);return await this.install(Object.assign({},fields),Object.assign(Object.assign({},config),{canisterId})),this.createActor(interfaceFactory,Object.assign(Object.assign({},config),{canisterId}))}static createActorClass(interfaceFactory,options){const service=interfaceFactory({IDL}),_CanisterActor=class _CanisterActor extends _Actor{constructor(config){if(!config.canisterId)throw new AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);const canisterId=typeof config.canisterId=="string"?Principal$1.fromText(config.canisterId):config.canisterId;super({config:Object.assign(Object.assign(Object.assign({},DEFAULT_ACTOR_CONFIG),config),{canisterId}),service});for(const[methodName,func]of service._fields)options?.httpDetails&&func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS),options?.certificate&&func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE),this[methodName]=_createActorMethod(this,methodName,func,config.blsVerify)}};__name(_CanisterActor,"CanisterActor");let CanisterActor=_CanisterActor;return CanisterActor}static createActor(interfaceFactory,configuration){if(!configuration.canisterId)throw new AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);return new(this.createActorClass(interfaceFactory))(configuration)}static createActorWithHttpDetails(interfaceFactory,configuration){return new(this.createActorClass(interfaceFactory,{httpDetails:!0}))(configuration)}static createActorWithExtendedDetails(interfaceFactory,configuration,actorClassOptions={httpDetails:!0,certificate:!0}){return new(this.createActorClass(interfaceFactory,actorClassOptions))(configuration)}};__name(_Actor,"Actor");let Actor=_Actor;function decodeReturnValue(types,msg){const returnValues=decode$1(types,buffer.Buffer.from(msg));switch(returnValues.length){case 0:return;case 1:return returnValues[0];default:return returnValues}}__name(decodeReturnValue,"decodeReturnValue");const DEFAULT_ACTOR_CONFIG={pollingStrategyFactory:defaultStrategy},ACTOR_METHOD_WITH_HTTP_DETAILS="http-details",ACTOR_METHOD_WITH_CERTIFICATE="certificate";function _createActorMethod(actor,methodName,func,blsVerify2){let caller;func.annotations.includes("query")||func.annotations.includes("composite_query")?caller=__name(async(options,...args)=>{var _a4,_b2;options=Object.assign(Object.assign({},options),(_b2=(_a4=actor[metadataSymbol].config).queryTransform)===null||_b2===void 0?void 0:_b2.call(_a4,methodName,args,Object.assign(Object.assign({},actor[metadataSymbol].config),options)));const agent=options.agent||actor[metadataSymbol].config.agent||getDefaultAgent(),cid=Principal$1.from(options.canisterId||actor[metadataSymbol].config.canisterId),arg=encode$1(func.argTypes,args),result=await agent.query(cid,{methodName,arg,effectiveCanisterId:options.effectiveCanisterId}),httpDetails=Object.assign(Object.assign({},result.httpDetails),{requestDetails:result.requestDetails});switch(result.status){case"rejected":throw new QueryCallRejectedError(cid,methodName,result);case"replied":return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)?{httpDetails,result:decodeReturnValue(func.retTypes,result.reply.arg)}:decodeReturnValue(func.retTypes,result.reply.arg)}},"caller"):caller=__name(async(options,...args)=>{var _a4,_b2;options=Object.assign(Object.assign({},options),(_b2=(_a4=actor[metadataSymbol].config).callTransform)===null||_b2===void 0?void 0:_b2.call(_a4,methodName,args,Object.assign(Object.assign({},actor[metadataSymbol].config),options)));const agent=options.agent||actor[metadataSymbol].config.agent||getDefaultAgent(),{canisterId,effectiveCanisterId,pollingStrategyFactory}=Object.assign(Object.assign(Object.assign({},DEFAULT_ACTOR_CONFIG),actor[metadataSymbol].config),options),cid=Principal$1.from(canisterId),ecid=effectiveCanisterId!==void 0?Principal$1.from(effectiveCanisterId):cid,arg=encode$1(func.argTypes,args),{requestId,response,requestDetails}=await agent.call(cid,{methodName,arg,effectiveCanisterId:ecid});let reply,certificate;if(response.body&&response.body.certificate){if(agent.rootKey==null)throw new Error("Agent is missing root key");const cert=response.body.certificate;certificate=await Certificate.create({certificate:bufFromBufLike(cert),rootKey:agent.rootKey,canisterId:Principal$1.from(canisterId),blsVerify:blsVerify2});const path=[new TextEncoder().encode("request_status"),requestId];switch(new TextDecoder().decode(lookupResultToBuffer(certificate.lookup([...path,"status"])))){case"replied":reply=lookupResultToBuffer(certificate.lookup([...path,"reply"]));break;case"rejected":{const rejectCode=new Uint8Array(lookupResultToBuffer(certificate.lookup([...path,"reject_code"])))[0],rejectMessage=new TextDecoder().decode(lookupResultToBuffer(certificate.lookup([...path,"reject_message"]))),error_code_buf=lookupResultToBuffer(certificate.lookup([...path,"error_code"])),error_code=error_code_buf?new TextDecoder().decode(error_code_buf):void 0;throw new UpdateCallRejectedError(cid,methodName,requestId,response,rejectCode,rejectMessage,error_code)}}}else if(response.body&&"reject_message"in response.body){const{reject_code,reject_message,error_code}=response.body;throw new UpdateCallRejectedError(cid,methodName,requestId,response,reject_code,reject_message,error_code)}if(response.status===202){const pollStrategy=pollingStrategyFactory(),response2=await pollForResponse(agent,ecid,requestId,pollStrategy,blsVerify2);certificate=response2.certificate,reply=response2.reply}const shouldIncludeHttpDetails=func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS),shouldIncludeCertificate=func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE),httpDetails=Object.assign(Object.assign({},response),{requestDetails});if(reply!==void 0)return shouldIncludeHttpDetails&&shouldIncludeCertificate?{httpDetails,certificate,result:decodeReturnValue(func.retTypes,reply)}:shouldIncludeCertificate?{certificate,result:decodeReturnValue(func.retTypes,reply)}:shouldIncludeHttpDetails?{httpDetails,result:decodeReturnValue(func.retTypes,reply)}:decodeReturnValue(func.retTypes,reply);if(func.retTypes.length===0)return shouldIncludeHttpDetails?{httpDetails:response,result:void 0}:void 0;throw new Error(`Call was returned undefined, but type [${func.retTypes.join(",")}].`)},"caller");const handler=__name((...args)=>caller({},...args),"handler");return handler.withOptions=options=>(...args)=>caller(options,...args),handler}__name(_createActorMethod,"_createActorMethod");function getManagementCanister(config){function transform(methodName,args){if(config.effectiveCanisterId)return{effectiveCanisterId:Principal$1.from(config.effectiveCanisterId)};const first=args[0];let effectiveCanisterId=Principal$1.fromHex("");return first&&typeof first=="object"&&first.target_canister&&methodName==="install_chunked_code"&&(effectiveCanisterId=Principal$1.from(first.target_canister)),first&&typeof first=="object"&&first.canister_id&&(effectiveCanisterId=Principal$1.from(first.canister_id)),{effectiveCanisterId}}return __name(transform,"transform"),Actor.createActor(managementCanisterIdl,Object.assign(Object.assign(Object.assign({},config),{canisterId:Principal$1.fromHex("")}),{callTransform:transform,queryTransform:transform}))}__name(getManagementCanister,"getManagementCanister");const _AdvancedActor=class _AdvancedActor extends Actor{constructor(metadata){super(metadata)}};__name(_AdvancedActor,"AdvancedActor");let AdvancedActor=_AdvancedActor;const assetCanister=__name(({IDL:IDL2})=>IDL2.Service({retrieve:IDL2.Func([IDL2.Text],[IDL2.Vec(IDL2.Nat8)],["query"]),store:IDL2.Func([IDL2.Text,IDL2.Vec(IDL2.Nat8)],[],[])}),"assetCanister");function createAssetCanisterActor(config){return Actor.createActor(assetCanister,config)}__name(createAssetCanisterActor,"createAssetCanisterActor");async function fetchCandid(canisterId,agent){agent||(agent=await HttpAgent.create());const candid=(await request({agent,canisterId:Principal$1.fromText(canisterId),paths:["candid"]})).get("candid");if(candid)return candid;const tmpHackInterface=__name(({IDL:IDL2})=>IDL2.Service({__get_candid_interface_tmp_hack:IDL2.Func([],[IDL2.Text],["query"])}),"tmpHackInterface");return await Actor.createActor(tmpHackInterface,{agent,canisterId}).__get_candid_interface_tmp_hack()}__name(fetchCandid,"fetchCandid");const index=Object.freeze(Object.defineProperty({__proto__:null,ACTOR_METHOD_WITH_CERTIFICATE,ACTOR_METHOD_WITH_HTTP_DETAILS,Actor,ActorCallError,AdvancedActor,AgentCallError,AgentHTTPResponseError,AgentQueryError,AgentReadStateError,AnonymousIdentity,CanisterStatus:index$2,Cbor:cbor,Certificate,CertificateVerificationError,DER_COSE_OID,ED25519_OID,Ed25519PublicKey:Ed25519PublicKey$1,Expiry,HttpAgent,IC_ROOT_KEY,IdentityInvalidError,get LookupStatus(){return LookupStatus},MANAGEMENT_CANISTER_ID,get NodeType(){return NodeType},Observable,ObservableLog,ProxyAgent,get ProxyMessageKind(){return ProxyMessageKind},ProxyStubAgent,QueryCallRejectedError,get ReplicaRejectCode(){return ReplicaRejectCode},get RequestStatusResponseStatus(){return RequestStatusResponseStatus},SECP256K1_OID,SignIdentity,get SubmitRequestType(){return SubmitRequestType},UpdateCallRejectedError,blsVerify,bufEquals,bufFromBufLike:bufFromBufLike$1,check_canister_ranges,compare,concat:concat$1,createAssetCanisterActor,createIdentityDescriptor,decodeLen,decodeLenBytes,defaultStrategy,encodeLen,encodeLenBytes,fetchCandid,find_label,flatten_forks,fromHex,getDefaultAgent,getManagementCanister,hash,hashOfMap,hashTreeToString,hashValue,httpHeadersTransform,lookupResultToBuffer,lookup_path,makeExpiryTransform,makeNonce,makeNonceTransform,pollForResponse,polling:index$1,randomNumber,reconstruct,requestIdOf,strategy,toHex,uint8ToBuf:uint8ToBuf$1,unwrapDER,verify,wrapDER},Symbol.toStringTag,{value:"Module"}));var __classPrivateFieldSet$3=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$3=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_Ed25519PublicKey_rawKey,_Ed25519PublicKey_derKey,_Ed25519KeyIdentity_publicKey,_Ed25519KeyIdentity_privateKey;function isObject(value){return value!==null&&typeof value=="object"}__name(isObject,"isObject");const _Ed25519PublicKey=class _Ed25519PublicKey{constructor(key){if(_Ed25519PublicKey_rawKey.set(this,void 0),_Ed25519PublicKey_derKey.set(this,void 0),key.byteLength!==_Ed25519PublicKey.RAW_KEY_LENGTH)throw new Error("An Ed25519 public key must be exactly 32bytes long");__classPrivateFieldSet$3(this,_Ed25519PublicKey_rawKey,bufFromBufLike$1(key),"f"),__classPrivateFieldSet$3(this,_Ed25519PublicKey_derKey,_Ed25519PublicKey.derEncode(key),"f")}static from(maybeKey){if(typeof maybeKey=="string"){const key=fromHex(maybeKey);return this.fromRaw(key)}else if(isObject(maybeKey)){const key=maybeKey;if(isObject(key)&&Object.hasOwnProperty.call(key,"__derEncodedPublicKey__"))return this.fromDer(key);if(ArrayBuffer.isView(key)){const view=key;return this.fromRaw(bufFromBufLike$1(view.buffer))}else{if(key instanceof ArrayBuffer)return this.fromRaw(key);if("rawKey"in key)return this.fromRaw(key.rawKey);if("derKey"in key)return this.fromDer(key.derKey);if("toDer"in key)return this.fromDer(key.toDer())}}throw new Error("Cannot construct Ed25519PublicKey from the provided key.")}static fromRaw(rawKey){return new _Ed25519PublicKey(rawKey)}static fromDer(derKey){return new _Ed25519PublicKey(this.derDecode(derKey))}static derEncode(publicKey){const key=wrapDER(publicKey,ED25519_OID).buffer;return key.__derEncodedPublicKey__=void 0,key}static derDecode(key){const unwrapped=unwrapDER(key,ED25519_OID);if(unwrapped.length!==this.RAW_KEY_LENGTH)throw new Error("An Ed25519 public key must be exactly 32bytes long");return bufFromBufLike$1(unwrapped)}get rawKey(){return __classPrivateFieldGet$3(this,_Ed25519PublicKey_rawKey,"f")}get derKey(){return __classPrivateFieldGet$3(this,_Ed25519PublicKey_derKey,"f")}toDer(){return this.derKey}toRaw(){return this.rawKey}};__name(_Ed25519PublicKey,"Ed25519PublicKey");let Ed25519PublicKey=_Ed25519PublicKey;_Ed25519PublicKey_rawKey=new WeakMap,_Ed25519PublicKey_derKey=new WeakMap;Ed25519PublicKey.RAW_KEY_LENGTH=32;const _Ed25519KeyIdentity=class _Ed25519KeyIdentity extends SignIdentity{constructor(publicKey,privateKey){super(),_Ed25519KeyIdentity_publicKey.set(this,void 0),_Ed25519KeyIdentity_privateKey.set(this,void 0),__classPrivateFieldSet$3(this,_Ed25519KeyIdentity_publicKey,Ed25519PublicKey.from(publicKey),"f"),__classPrivateFieldSet$3(this,_Ed25519KeyIdentity_privateKey,new Uint8Array(privateKey),"f")}static generate(seed){if(seed&&seed.length!==32)throw new Error("Ed25519 Seed needs to be 32 bytes long.");seed||(seed=ed25519.utils.randomPrivateKey()),bufEquals(seed,new Uint8Array(new Array(32).fill(0)))&&console.warn("Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.");const sk=new Uint8Array(32);for(let i=0;i<32;i++)sk[i]=new Uint8Array(seed)[i];const pk=ed25519.getPublicKey(sk);return _Ed25519KeyIdentity.fromKeyPair(pk,sk)}static fromParsedJson(obj){const[publicKeyDer,privateKeyRaw]=obj;return new _Ed25519KeyIdentity(Ed25519PublicKey.fromDer(fromHex(publicKeyDer)),fromHex(privateKeyRaw))}static fromJSON(json){const parsed=JSON.parse(json);if(Array.isArray(parsed)){if(typeof parsed[0]=="string"&&typeof parsed[1]=="string")return this.fromParsedJson([parsed[0],parsed[1]]);throw new Error("Deserialization error: JSON must have at least 2 items.")}throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`)}static fromKeyPair(publicKey,privateKey){return new _Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey),privateKey)}static fromSecretKey(secretKey){const publicKey=ed25519.getPublicKey(new Uint8Array(secretKey));return _Ed25519KeyIdentity.fromKeyPair(publicKey,secretKey)}toJSON(){return[toHex(__classPrivateFieldGet$3(this,_Ed25519KeyIdentity_publicKey,"f").toDer()),toHex(__classPrivateFieldGet$3(this,_Ed25519KeyIdentity_privateKey,"f"))]}getKeyPair(){return{secretKey:__classPrivateFieldGet$3(this,_Ed25519KeyIdentity_privateKey,"f"),publicKey:__classPrivateFieldGet$3(this,_Ed25519KeyIdentity_publicKey,"f")}}getPublicKey(){return __classPrivateFieldGet$3(this,_Ed25519KeyIdentity_publicKey,"f")}async sign(challenge){const blob=new Uint8Array(challenge),signature=uint8ToBuf$1(ed25519.sign(blob,__classPrivateFieldGet$3(this,_Ed25519KeyIdentity_privateKey,"f").slice(0,32)));return Object.defineProperty(signature,"__signature__",{enumerable:!1,value:void 0}),signature}static verify(sig,msg,pk){const[signature,message,publicKey]=[sig,msg,pk].map(x=>(typeof x=="string"&&(x=fromHex(x)),x instanceof Uint8Array&&(x=bufFromBufLike$1(x.buffer)),new Uint8Array(x)));return ed25519.verify(signature,message,publicKey)}};__name(_Ed25519KeyIdentity,"Ed25519KeyIdentity");let Ed25519KeyIdentity=_Ed25519KeyIdentity;_Ed25519KeyIdentity_publicKey=new WeakMap,_Ed25519KeyIdentity_privateKey=new WeakMap;const _CryptoError=class _CryptoError extends Error{constructor(message){super(message),this.message=message,Object.setPrototypeOf(this,_CryptoError.prototype)}};__name(_CryptoError,"CryptoError");let CryptoError=_CryptoError;function _getEffectiveCrypto(subtleCrypto){if(typeof globalThis<"u"&&globalThis.crypto&&globalThis.crypto.subtle)return globalThis.crypto.subtle;if(subtleCrypto)return subtleCrypto;if(typeof crypto<"u"&&crypto.subtle)return crypto.subtle;throw new CryptoError("Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto")}__name(_getEffectiveCrypto,"_getEffectiveCrypto");const _ECDSAKeyIdentity=class _ECDSAKeyIdentity extends SignIdentity{constructor(keyPair,derKey,subtleCrypto){super(),this._keyPair=keyPair,this._derKey=derKey,this._subtleCrypto=subtleCrypto}static async generate(options){const{extractable=!1,keyUsages=["sign","verify"],subtleCrypto}=options??{},effectiveCrypto=_getEffectiveCrypto(subtleCrypto),keyPair=await effectiveCrypto.generateKey({name:"ECDSA",namedCurve:"P-256"},extractable,keyUsages),derKey=await effectiveCrypto.exportKey("spki",keyPair.publicKey);return new this(keyPair,derKey,effectiveCrypto)}static async fromKeyPair(keyPair,subtleCrypto){const effectiveCrypto=_getEffectiveCrypto(subtleCrypto),derKey=await effectiveCrypto.exportKey("spki",keyPair.publicKey);return new _ECDSAKeyIdentity(keyPair,derKey,effectiveCrypto)}getKeyPair(){return this._keyPair}getPublicKey(){const derKey=this._derKey,key=Object.create(this._keyPair.publicKey);return key.toDer=function(){return derKey},key}async sign(challenge){const params={name:"ECDSA",hash:{name:"SHA-256"}};return await this._subtleCrypto.sign(params,this._keyPair.privateKey,challenge)}};__name(_ECDSAKeyIdentity,"ECDSAKeyIdentity");let ECDSAKeyIdentity=_ECDSAKeyIdentity;var __classPrivateFieldSet$2=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$2=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_PartialIdentity_inner;const _PartialIdentity=class _PartialIdentity{constructor(inner){_PartialIdentity_inner.set(this,void 0),__classPrivateFieldSet$2(this,_PartialIdentity_inner,inner,"f")}get rawKey(){return __classPrivateFieldGet$2(this,_PartialIdentity_inner,"f").rawKey}get derKey(){return __classPrivateFieldGet$2(this,_PartialIdentity_inner,"f").derKey}toDer(){return __classPrivateFieldGet$2(this,_PartialIdentity_inner,"f").toDer()}getPublicKey(){return __classPrivateFieldGet$2(this,_PartialIdentity_inner,"f")}getPrincipal(){if(!__classPrivateFieldGet$2(this,_PartialIdentity_inner,"f").rawKey)throw new Error("Cannot get principal from a public key without a raw key.");return Principal$1.fromUint8Array(new Uint8Array(__classPrivateFieldGet$2(this,_PartialIdentity_inner,"f").rawKey))}transformRequest(){return Promise.reject("Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.")}};__name(_PartialIdentity,"PartialIdentity");let PartialIdentity=_PartialIdentity;_PartialIdentity_inner=new WeakMap;var __classPrivateFieldSet$1=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet$1=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},__rest=globalThis&&globalThis.__rest||function(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]]);return t},_PartialDelegationIdentity_delegation;const domainSeparator=new TextEncoder().encode("ic-request-auth-delegation"),requestDomainSeparator=new TextEncoder().encode(`
ic-request`);function _parseBlob(value){if(typeof value!="string"||value.length<64)throw new Error("Invalid public key.");return fromHex(value)}__name(_parseBlob,"_parseBlob");const _Delegation=class _Delegation{constructor(pubkey,expiration,targets){this.pubkey=pubkey,this.expiration=expiration,this.targets=targets}toCBOR(){return src.value.map(Object.assign({pubkey:src.value.bytes(this.pubkey),expiration:src.value.u64(this.expiration.toString(16),16)},this.targets&&{targets:src.value.array(this.targets.map(t=>src.value.bytes(bufFromBufLike(t.toUint8Array()))))}))}toJSON(){return Object.assign({expiration:this.expiration.toString(16),pubkey:toHex(this.pubkey)},this.targets&&{targets:this.targets.map(p=>p.toHex())})}};__name(_Delegation,"Delegation");let Delegation=_Delegation;async function _createSingleDelegation(from,to,expiration,targets){const delegation=new Delegation(to.toDer(),(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(+expiration)*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1e6),targets),challenge=new Uint8Array([...domainSeparator,...new Uint8Array(requestIdOf(Object.assign({},delegation)))]),signature=await from.sign(bufFromBufLike(challenge));return{delegation,signature}}__name(_createSingleDelegation,"_createSingleDelegation");const _DelegationChain=class _DelegationChain{constructor(delegations,publicKey){this.delegations=delegations,this.publicKey=publicKey}static async create(from,to,expiration=new Date(Date.now()+15*60*1e3),options={}){var _a4,_b2;const delegation=await _createSingleDelegation(from,to,expiration,options.targets);return new _DelegationChain([...((_a4=options.previous)===null||_a4===void 0?void 0:_a4.delegations)||[],delegation],((_b2=options.previous)===null||_b2===void 0?void 0:_b2.publicKey)||from.getPublicKey().toDer())}static fromJSON(json){const{publicKey,delegations}=typeof json=="string"?JSON.parse(json):json;if(!Array.isArray(delegations))throw new Error("Invalid delegations.");const parsedDelegations=delegations.map(signedDelegation=>{const{delegation,signature}=signedDelegation,{pubkey,expiration,targets}=delegation;if(targets!==void 0&&!Array.isArray(targets))throw new Error("Invalid targets.");return{delegation:new Delegation(_parseBlob(pubkey),(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})("0x"+expiration),targets&&targets.map(t=>{if(typeof t!="string")throw new Error("Invalid target.");return Principal$1.fromHex(t)})),signature:_parseBlob(signature)}});return new this(parsedDelegations,_parseBlob(publicKey))}static fromDelegations(delegations,publicKey){return new this(delegations,publicKey)}toJSON(){return{delegations:this.delegations.map(signedDelegation=>{const{delegation,signature}=signedDelegation,{targets}=delegation;return{delegation:Object.assign({expiration:delegation.expiration.toString(16),pubkey:toHex(delegation.pubkey)},targets&&{targets:targets.map(t=>t.toHex())}),signature:toHex(signature)}}),publicKey:toHex(this.publicKey)}}};__name(_DelegationChain,"DelegationChain");let DelegationChain=_DelegationChain;const _DelegationIdentity=class _DelegationIdentity extends SignIdentity{constructor(_inner,_delegation){super(),this._inner=_inner,this._delegation=_delegation}static fromDelegation(key,delegation){return new this(key,delegation)}getDelegation(){return this._delegation}getPublicKey(){return{derKey:this._delegation.publicKey,toDer:()=>this._delegation.publicKey}}sign(blob){return this._inner.sign(blob)}async transformRequest(request2){const{body}=request2,fields=__rest(request2,["body"]),requestId=await requestIdOf(body);return Object.assign(Object.assign({},fields),{body:{content:body,sender_sig:await this.sign(bufFromBufLike(new Uint8Array([...requestDomainSeparator,...new Uint8Array(requestId)]))),sender_delegation:this._delegation.delegations,sender_pubkey:this._delegation.publicKey}})}};__name(_DelegationIdentity,"DelegationIdentity");let DelegationIdentity=_DelegationIdentity;const _PartialDelegationIdentity=class _PartialDelegationIdentity extends PartialIdentity{constructor(inner,delegation){super(inner),_PartialDelegationIdentity_delegation.set(this,void 0),__classPrivateFieldSet$1(this,_PartialDelegationIdentity_delegation,delegation,"f")}get delegation(){return __classPrivateFieldGet$1(this,_PartialDelegationIdentity_delegation,"f")}static fromDelegation(key,delegation){return new _PartialDelegationIdentity(key,delegation)}};__name(_PartialDelegationIdentity,"PartialDelegationIdentity");let PartialDelegationIdentity=_PartialDelegationIdentity;_PartialDelegationIdentity_delegation=new WeakMap;function isDelegationValid(chain2,checks){for(const{delegation}of chain2.delegations)if(+new Date(Number(delegation.expiration/(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(1e6)))<=+Date.now())return!1;const scopes=[],maybeScope=checks?.scope;maybeScope&&(Array.isArray(maybeScope)?scopes.push(...maybeScope.map(s=>typeof s=="string"?Principal$1.fromText(s):s)):scopes.push(typeof maybeScope=="string"?Principal$1.fromText(maybeScope):maybeScope));for(const s of scopes){const scope=s.toText();for(const{delegation}of chain2.delegations){if(delegation.targets===void 0)continue;let none=!0;for(const target of delegation.targets)if(target.toText()===scope){none=!1;break}if(none)return!1}}return!0}__name(isDelegationValid,"isDelegationValid");var PubKeyCoseAlgo;(function(PubKeyCoseAlgo2){PubKeyCoseAlgo2[PubKeyCoseAlgo2.ECDSA_WITH_SHA256=-7]="ECDSA_WITH_SHA256"})(PubKeyCoseAlgo||(PubKeyCoseAlgo={}));const events=["mousedown","mousemove","keydown","touchstart","wheel"],_IdleManager=class _IdleManager{constructor(options={}){var _a4;this.callbacks=[],this.idleTimeout=10*60*1e3,this.timeoutID=void 0;const{onIdle,idleTimeout=10*60*1e3}=options||{};this.callbacks=onIdle?[onIdle]:[],this.idleTimeout=idleTimeout;const _resetTimer=this._resetTimer.bind(this);window.addEventListener("load",_resetTimer,!0),events.forEach(function(name){document.addEventListener(name,_resetTimer,!0)});const debounce=__name((func,wait)=>{let timeout2;return(...args)=>{const context=this,later=__name(function(){timeout2=void 0,func.apply(context,args)},"later");clearTimeout(timeout2),timeout2=window.setTimeout(later,wait)}},"debounce");if(options?.captureScroll){const scroll=debounce(_resetTimer,(_a4=options?.scrollDebounce)!==null&&_a4!==void 0?_a4:100);window.addEventListener("scroll",scroll,!0)}_resetTimer()}static create(options={}){return new this(options)}registerCallback(callback){this.callbacks.push(callback)}exit(){clearTimeout(this.timeoutID),window.removeEventListener("load",this._resetTimer,!0);const _resetTimer=this._resetTimer.bind(this);events.forEach(function(name){document.removeEventListener(name,_resetTimer,!0)}),this.callbacks.forEach(cb=>cb())}_resetTimer(){const exit=this.exit.bind(this);window.clearTimeout(this.timeoutID),this.timeoutID=window.setTimeout(exit,this.idleTimeout)}};__name(_IdleManager,"IdleManager");let IdleManager=_IdleManager;const AUTH_DB_NAME="auth-client-db",OBJECT_STORE_NAME="ic-keyval",_openDbStore=__name(async(dbName=AUTH_DB_NAME,storeName=OBJECT_STORE_NAME,version)=>(isBrowser&&(localStorage!=null&&localStorage.getItem(KEY_STORAGE_DELEGATION))&&(localStorage.removeItem(KEY_STORAGE_DELEGATION),localStorage.removeItem(KEY_STORAGE_KEY)),await openDB(dbName,version,{upgrade:database=>{database.objectStoreNames.contains(storeName)&&database.clear(storeName),database.createObjectStore(storeName)}})),"_openDbStore");async function _getValue(db,storeName,key){return await db.get(storeName,key)}__name(_getValue,"_getValue");async function _setValue(db,storeName,key,value){return await db.put(storeName,value,key)}__name(_setValue,"_setValue");async function _removeValue(db,storeName,key){return await db.delete(storeName,key)}__name(_removeValue,"_removeValue");const _IdbKeyVal=class _IdbKeyVal{constructor(_db,_storeName){this._db=_db,this._storeName=_storeName}static async create(options){const{dbName=AUTH_DB_NAME,storeName=OBJECT_STORE_NAME,version=DB_VERSION}=options??{},db=await _openDbStore(dbName,storeName,version);return new _IdbKeyVal(db,storeName)}async set(key,value){return await _setValue(this._db,this._storeName,key,value)}async get(key){var _a4;return(_a4=await _getValue(this._db,this._storeName,key))!==null&&_a4!==void 0?_a4:null}async remove(key){return await _removeValue(this._db,this._storeName,key)}};__name(_IdbKeyVal,"IdbKeyVal");let IdbKeyVal=_IdbKeyVal;var __classPrivateFieldSet=globalThis&&globalThis.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet=globalThis&&globalThis.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state=="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)},_IdbStorage_options;const KEY_STORAGE_KEY="identity",KEY_STORAGE_DELEGATION="delegation",KEY_VECTOR="iv",DB_VERSION=1,isBrowser=typeof window<"u",_LocalStorage=class _LocalStorage{constructor(prefix="ic-",_localStorage){this.prefix=prefix,this._localStorage=_localStorage}get(key){return Promise.resolve(this._getLocalStorage().getItem(this.prefix+key))}set(key,value){return this._getLocalStorage().setItem(this.prefix+key,value),Promise.resolve()}remove(key){return this._getLocalStorage().removeItem(this.prefix+key),Promise.resolve()}_getLocalStorage(){if(this._localStorage)return this._localStorage;const ls=typeof window>"u"?typeof globalThis>"u"?typeof self>"u"?void 0:self.localStorage:globalThis.localStorage:window.localStorage;if(!ls)throw new Error("Could not find local storage.");return ls}};__name(_LocalStorage,"LocalStorage");let LocalStorage=_LocalStorage;const _IdbStorage=class _IdbStorage{constructor(options){_IdbStorage_options.set(this,void 0),__classPrivateFieldSet(this,_IdbStorage_options,options??{},"f")}get _db(){return new Promise(resolve=>{if(this.initializedDb){resolve(this.initializedDb);return}IdbKeyVal.create(__classPrivateFieldGet(this,_IdbStorage_options,"f")).then(db=>{this.initializedDb=db,resolve(db)})})}async get(key){return await(await this._db).get(key)}async set(key,value){await(await this._db).set(key,value)}async remove(key){await(await this._db).remove(key)}};__name(_IdbStorage,"IdbStorage");let IdbStorage=_IdbStorage;_IdbStorage_options=new WeakMap;const IDENTITY_PROVIDER_DEFAULT="https://identity.internetcomputer.org",IDENTITY_PROVIDER_ENDPOINT="#authorize",ECDSA_KEY_LABEL="ECDSA",ED25519_KEY_LABEL="Ed25519",INTERRUPT_CHECK_INTERVAL=500,ERROR_USER_INTERRUPT="UserInterrupt",_AuthClient=class _AuthClient{constructor(_identity,_key,_chain,_storage,idleManager,_createOptions,_idpWindow,_eventHandler){this._identity=_identity,this._key=_key,this._chain=_chain,this._storage=_storage,this.idleManager=idleManager,this._createOptions=_createOptions,this._idpWindow=_idpWindow,this._eventHandler=_eventHandler,this._registerDefaultIdleCallback()}static async create(options={}){var _a4,_b2,_c;const storage=(_a4=options.storage)!==null&&_a4!==void 0?_a4:new IdbStorage,keyType=(_b2=options.keyType)!==null&&_b2!==void 0?_b2:ECDSA_KEY_LABEL;let key=null;if(options.identity)key=options.identity;else{let maybeIdentityStorage=await storage.get(KEY_STORAGE_KEY);if(!maybeIdentityStorage&&isBrowser)try{const fallbackLocalStorage=new LocalStorage,localChain=await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION),localKey=await fallbackLocalStorage.get(KEY_STORAGE_KEY);localChain&&localKey&&keyType===ECDSA_KEY_LABEL&&(console.log("Discovered an identity stored in localstorage. Migrating to IndexedDB"),await storage.set(KEY_STORAGE_DELEGATION,localChain),await storage.set(KEY_STORAGE_KEY,localKey),maybeIdentityStorage=localChain,await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION),await fallbackLocalStorage.remove(KEY_STORAGE_KEY))}catch(error){console.error("error while attempting to recover localstorage: "+error)}if(maybeIdentityStorage)try{typeof maybeIdentityStorage=="object"?keyType===ED25519_KEY_LABEL&&typeof maybeIdentityStorage=="string"?key=await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage):key=await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage):typeof maybeIdentityStorage=="string"&&(key=Ed25519KeyIdentity.fromJSON(maybeIdentityStorage))}catch{}}let identity=new AnonymousIdentity,chain2=null;if(key)try{const chainStorage=await storage.get(KEY_STORAGE_DELEGATION);if(typeof chainStorage=="object"&&chainStorage!==null)throw new Error("Delegation chain is incorrectly stored. A delegation chain should be stored as a string.");options.identity?identity=options.identity:chainStorage&&(chain2=DelegationChain.fromJSON(chainStorage),isDelegationValid(chain2)?"toDer"in key?identity=PartialDelegationIdentity.fromDelegation(key,chain2):identity=DelegationIdentity.fromDelegation(key,chain2):(await _deleteStorage(storage),key=null))}catch(e){console.error(e),await _deleteStorage(storage),key=null}let idleManager;return!((_c=options.idleOptions)===null||_c===void 0)&&_c.disableIdle?idleManager=void 0:(chain2||options.identity)&&(idleManager=IdleManager.create(options.idleOptions)),key||(keyType===ED25519_KEY_LABEL?(key=await Ed25519KeyIdentity.generate(),await storage.set(KEY_STORAGE_KEY,JSON.stringify(key.toJSON()))):(options.storage&&keyType===ECDSA_KEY_LABEL&&console.warn(`You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`),key=await ECDSAKeyIdentity.generate(),await storage.set(KEY_STORAGE_KEY,key.getKeyPair()))),new this(identity,key,chain2,storage,idleManager,options)}_registerDefaultIdleCallback(){var _a4,_b2;const idleOptions=(_a4=this._createOptions)===null||_a4===void 0?void 0:_a4.idleOptions;!idleOptions?.onIdle&&!idleOptions?.disableDefaultIdleCallback&&((_b2=this.idleManager)===null||_b2===void 0||_b2.registerCallback(()=>{this.logout(),location.reload()}))}async _handleSuccess(message,onSuccess){var _a4,_b2;const delegations=message.delegations.map(signedDelegation=>({delegation:new Delegation(signedDelegation.delegation.pubkey,signedDelegation.delegation.expiration,signedDelegation.delegation.targets),signature:signedDelegation.signature.buffer})),delegationChain=DelegationChain.fromDelegations(delegations,message.userPublicKey.buffer),key=this._key;if(!key)return;this._chain=delegationChain,"toDer"in key?this._identity=PartialDelegationIdentity.fromDelegation(key,this._chain):this._identity=DelegationIdentity.fromDelegation(key,this._chain),(_a4=this._idpWindow)===null||_a4===void 0||_a4.close();const idleOptions=(_b2=this._createOptions)===null||_b2===void 0?void 0:_b2.idleOptions;!this.idleManager&&!idleOptions?.disableIdle&&(this.idleManager=IdleManager.create(idleOptions),this._registerDefaultIdleCallback()),this._removeEventListener(),delete this._idpWindow,this._chain&&await this._storage.set(KEY_STORAGE_DELEGATION,JSON.stringify(this._chain.toJSON())),onSuccess?.(message)}getIdentity(){return this._identity}async isAuthenticated(){return!this.getIdentity().getPrincipal().isAnonymous()&&this._chain!==null}async login(options){var _a4,_b2,_c,_d;const defaultTimeToLive=(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(8)*(value=>{try{return typeof value=="string"?parseInt(value,10)||0:Number(value)||0}catch{return 0}})(36e11),identityProviderUrl=new URL(((_a4=options?.identityProvider)===null||_a4===void 0?void 0:_a4.toString())||IDENTITY_PROVIDER_DEFAULT);identityProviderUrl.hash=IDENTITY_PROVIDER_ENDPOINT,(_b2=this._idpWindow)===null||_b2===void 0||_b2.close(),this._removeEventListener(),this._eventHandler=this._getEventHandler(identityProviderUrl,Object.assign({maxTimeToLive:(_c=options?.maxTimeToLive)!==null&&_c!==void 0?_c:defaultTimeToLive},options)),window.addEventListener("message",this._eventHandler),this._idpWindow=(_d=window.open(identityProviderUrl.toString(),"idpWindow",options?.windowOpenerFeatures))!==null&&_d!==void 0?_d:void 0;const checkInterruption=__name(()=>{this._idpWindow&&(this._idpWindow.closed?this._handleFailure(ERROR_USER_INTERRUPT,options?.onError):setTimeout(checkInterruption,INTERRUPT_CHECK_INTERVAL))},"checkInterruption");checkInterruption()}_getEventHandler(identityProviderUrl,options){return async event=>{var _a4,_b2,_c;if(event.origin!==identityProviderUrl.origin)return;const message=event.data;switch(message.kind){case"authorize-ready":{const request2=Object.assign({kind:"authorize-client",sessionPublicKey:new Uint8Array((_a4=this._key)===null||_a4===void 0?void 0:_a4.getPublicKey().toDer()),maxTimeToLive:options?.maxTimeToLive,allowPinAuthentication:options?.allowPinAuthentication,derivationOrigin:(_b2=options?.derivationOrigin)===null||_b2===void 0?void 0:_b2.toString()},options?.customValues);(_c=this._idpWindow)===null||_c===void 0||_c.postMessage(request2,identityProviderUrl.origin);break}case"authorize-client-success":try{await this._handleSuccess(message,options?.onSuccess)}catch(err){this._handleFailure(err.message,options?.onError)}break;case"authorize-client-failure":this._handleFailure(message.text,options?.onError);break}}}_handleFailure(errorMessage,onError){var _a4;(_a4=this._idpWindow)===null||_a4===void 0||_a4.close(),onError?.(errorMessage),this._removeEventListener(),delete this._idpWindow}_removeEventListener(){this._eventHandler&&window.removeEventListener("message",this._eventHandler),this._eventHandler=void 0}async logout(options={}){if(await _deleteStorage(this._storage),this._identity=new AnonymousIdentity,this._chain=null,options.returnTo)try{window.history.pushState({},"",options.returnTo)}catch{window.location.href=options.returnTo}}};__name(_AuthClient,"AuthClient");let AuthClient=_AuthClient;async function _deleteStorage(storage){await storage.remove(KEY_STORAGE_KEY),await storage.remove(KEY_STORAGE_DELEGATION),await storage.remove(KEY_VECTOR)}__name(_deleteStorage,"_deleteStorage");export{AuthClient as A,HttpAgent as H,Principal$1 as P,__vitePreload as _,Actor as a,index as i};
