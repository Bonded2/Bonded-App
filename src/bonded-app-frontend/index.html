<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, viewport-fit=cover" />
  <title>Bonded App - Relationship Verification for Immigration</title>
  <meta name="description" content="Bonded helps you collect and organize proof of your genuine relationship for visa, residency and citizenship applications." />
  <meta name="keywords" content="visa application, relationship verification, immigration, citizenship, relationship proof" />
  <base href="/" />
  <link rel="icon" href="/favicon.ico" />
  <link rel="manifest" href="/manifest.json" crossorigin="use-credentials" />
  
  <!-- Content Security Policy - Permissive for development, external services, and Yoti -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval' blob: data: https://cdn.jsdelivr.net https://sdk.yoti.com; style-src 'self' 'unsafe-inline' blob: data: https://fonts.googleapis.com; style-src-elem 'self' 'unsafe-inline' blob: data: https://fonts.googleapis.com; font-src 'self' data: blob: https://fonts.gstatic.com; connect-src 'self' http: https: ws: wss: blob: data: https://*.yoti.com https://api.yoti.com wss://*.yoti.com; img-src 'self' data: blob: https:; media-src 'self' data: blob:; worker-src 'self' blob: data:; object-src 'none'; base-uri 'self'; form-action 'self'; upgrade-insecure-requests;" />
  
  <!-- Permissions Policy - Define allowed features -->
  <meta http-equiv="Permissions-Policy" content="camera=self, microphone=(), geolocation=(), payment=(), usb=(), magnetometer=(), gyroscope=(), accelerometer=(), ambient-light-sensor=(), autoplay=(), encrypted-media=(), fullscreen=self, picture-in-picture=()" />
  
  <!-- ULTRA CRITICAL: Pre-emptive CBOR Setup -->
  <script>
    // ABSOLUTE FIRST - Set up CBOR before ANY other code
    (function() {
      'use strict';
      const CBOR = class SelfDescribeCborSerializer {
        constructor() { this.buffer = []; }
        serialize(value) {
          try {
            return new TextEncoder().encode(JSON.stringify(value, (k, v) => 
              typeof v === 'bigint' ? Number(v) : v
            ));
          } catch (e) { return new Uint8Array(0); }
        }
        static serialize(value) { return new this().serialize(value); }
      };
      
      // Create src.value.SelfDescribeCborSerializer structure
      window.src = { value: { SelfDescribeCborSerializer: CBOR }, SelfDescribeCborSerializer: CBOR };
      window.SelfDescribeCborSerializer = CBOR;
      globalThis.SelfDescribeCborSerializer = CBOR;
      if (typeof self !== 'undefined') self.SelfDescribeCborSerializer = CBOR;
      
      // Also set on common module names
      ['cbor', 'borc', 'CBOR'].forEach(name => {
        window[name] = { value: { SelfDescribeCborSerializer: CBOR }, SelfDescribeCborSerializer: CBOR };
      });
      
      // CRITICAL: Override undefined access to return CBOR when needed
      const originalValueOf = Object.prototype.valueOf;
      const originalToString = Object.prototype.toString;
      
      // Create a special undefined proxy
      try {
        const undefinedProxy = new Proxy({}, {
          get(target, prop) {
            if (prop === 'SelfDescribeCborSerializer') {
              console.log('🔧 Intercepted undefined.SelfDescribeCborSerializer access');
              return CBOR;
            }
            return undefined;
          }
        });
        
        // Try to make undefined return our proxy in certain contexts
        Object.defineProperty(window, 'undefined', {
          get() {
            const stack = new Error().stack;
            if (stack && stack.includes('icp-sdk')) {
              return undefinedProxy;
            }
            return void 0;
          },
          configurable: true
        });
      } catch (e) {
        // Fallback if we can't override undefined
      }
      
      // Also patch potential module loading patterns
      const moduleNames = ['cbor', 'borc', 'cbor-web', 'cborg', '@dfinity/cbor'];
      moduleNames.forEach(name => {
        try {
          Object.defineProperty(window, name, {
            get() {
              return { 
                value: { SelfDescribeCborSerializer: CBOR }, 
                SelfDescribeCborSerializer: CBOR,
                default: { SelfDescribeCborSerializer: CBOR }
              };
            },
            configurable: true
          });
        } catch (e) {}
      });
      
      console.log('🛡️ ULTRA-EARLY CBOR polyfill set on src.value.SelfDescribeCborSerializer');
      
      // CRITICAL: Add getter trap to Object.prototype as last resort
      try {
        Object.defineProperty(Object.prototype, 'SelfDescribeCborSerializer', {
          get() {
            console.warn('🔧 Fallback CBOR access via Object.prototype');
            return CBOR;
          },
          configurable: true,
          enumerable: false
        });
      } catch (e) {
        console.warn('Could not set Object.prototype.SelfDescribeCborSerializer');
      }
      
      // LAST RESORT: Global error handler for CBOR access
      window.addEventListener('error', function(e) {
        if (e.message && e.message.includes("Cannot read properties of undefined") && 
            e.message.includes("SelfDescribeCborSerializer")) {
          console.warn('🚨 Caught CBOR error, attempting recovery...');
          e.preventDefault();
          e.stopPropagation();
          
          // Try to fix the issue by setting CBOR on more locations
          const targets = [window, globalThis, self, window.src, window.cbor, window.borc];
          targets.forEach(target => {
            if (target && typeof target === 'object') {
              try {
                if (!target.SelfDescribeCborSerializer) {
                  target.SelfDescribeCborSerializer = CBOR;
                }
                if (!target.value) {
                  target.value = { SelfDescribeCborSerializer: CBOR };
                } else if (!target.value.SelfDescribeCborSerializer) {
                  target.value.SelfDescribeCborSerializer = CBOR;
                }
              } catch (err) {}
            }
          });
          
          // Also try to reload the page once if error persists
          if (!window.__cborErrorReloaded) {
            window.__cborErrorReloaded = true;
            console.warn('🔄 Reloading page to fix CBOR error...');
            setTimeout(() => location.reload(), 100);
          }
          
          return false;
        }
      }, true);
    })();
  </script>
  
  <!-- NUCLEAR BigInt polyfill - MUST BE FIRST SCRIPT -->
  <script>
    // NUCLEAR BigInt elimination for ICP/DFX compatibility - ZERO TOLERANCE
    (function() {
      'use strict';
      
      // Safe BigInt replacement function
      function SafeBigInt(value) {
        try {
          if (value === null || value === undefined) return 0;
          if (typeof value === 'string') {
            if (value.trim() === '') return 0;
            const parsed = parseInt(value, 10);
            return isNaN(parsed) ? 0 : parsed;
          }
          if (typeof value === 'number') return isNaN(value) ? 0 : Math.trunc(value);
          if (typeof value === 'bigint') {
            try {
              return Number(value);
            } catch (e) {
              return parseInt(value.toString(), 10) || 0;
            }
          }
          if (typeof value === 'boolean') return value ? 1 : 0;
          if (typeof value === 'object' && value && value.toString) {
            const str = value.toString();
            const parsed = parseInt(str, 10);
            return isNaN(parsed) ? 0 : parsed;
          }
          const converted = Number(value);
          return isNaN(converted) ? 0 : Math.trunc(converted);
        } catch (error) {
          return 0;
        }
      }
      
      // Static methods
      SafeBigInt.asIntN = (bits, value) => {
        try {
          const num = SafeBigInt(value);
          if (bits === 32) return num | 0;
          if (bits === 64) return num;
          return num;
        } catch (e) { return 0; }
      };
      
      SafeBigInt.asUintN = (bits, value) => {
        try {
          const num = Math.abs(SafeBigInt(value));
          if (bits === 32) return num >>> 0;
          if (bits === 64) return num;
          return num;
        } catch (e) { return 0; }
      };
      
      // IMMEDIATE GLOBAL REPLACEMENT - ALL CONTEXTS
      const contexts = [window, globalThis, self];
      contexts.forEach(ctx => {
        if (ctx && typeof ctx === 'object') {
          try {
            ctx.BigInt = SafeBigInt;
          } catch (e) {}
        }
      });
      
      // Override Number constructor for BigInt safety
      if (window.Number) {
        const OriginalNumber = window.Number;
        window.Number = function(value) {
          if (typeof value === 'bigint') {
            try {
              return OriginalNumber(value.toString());
            } catch (e) {
              return 0;
            }
          }
          try {
            return OriginalNumber(value);
          } catch (e) {
            return 0;
          }
        };
        
        // Copy all Number static properties
        Object.getOwnPropertyNames(OriginalNumber).forEach(name => {
          if (name !== 'length' && name !== 'name' && name !== 'prototype') {
            try {
              window.Number[name] = OriginalNumber[name];
            } catch (e) {}
          }
        });
        
        Object.setPrototypeOf(window.Number, OriginalNumber);
        window.Number.prototype = OriginalNumber.prototype;
      }
      
      // NUCLEAR JSON.stringify override
      if (JSON && JSON.stringify) {
        const originalStringify = JSON.stringify;
        JSON.stringify = function(value, replacer, space) {
          const safeReplacer = function(key, val) {
            if (typeof val === 'bigint') return SafeBigInt(val);
            if (val && typeof val === 'object' && val.constructor) {
              try {
                if (val.constructor.name === 'BigInt') return SafeBigInt(val);
              } catch (e) {}
            }
            return typeof replacer === 'function' ? replacer(key, val) : val;
          };
          
          try {
            return originalStringify.call(this, value, safeReplacer, space);
          } catch (error) {
            try {
              return originalStringify.call(this, value, (key, val) => {
                if (typeof val === 'bigint') return Number(val) || 0;
                return val;
              }, space);
            } catch (e) {
              return '{}';
            }
          }
        };
      }
      
      // TOTAL error suppression for BigInt
      const originalError = window.Error;
      window.Error = function(message) {
        if (typeof message === 'string' && (
          message.includes('BigInt') || 
          message.includes('Cannot convert') ||
          message.includes('convert') && message.includes('bigint') ||
          message.includes('bigint')
        )) {
          return new originalError('BigInt error (suppressed for compatibility)');
        }
        return new originalError(message);
      };
      
      // Global error handler for BigInt errors
      window.addEventListener('error', function(e) {
        if (e.message && (
          e.message.includes('BigInt') || 
          e.message.includes('Cannot convert') ||
          e.message.includes('bigint')
        )) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }, { capture: true });
      
      // Unhandled promise rejections
      window.addEventListener('unhandledrejection', function(e) {
        if (e.reason && e.reason.message && (
          e.reason.message.includes('BigInt') || 
          e.reason.message.includes('Cannot convert') ||
          e.reason.message.includes('bigint')
        )) {
          e.preventDefault();
          return false;
        }
      });
      
      // VENDOR BUNDLE PATCH - intercept script loading
      const originalCreateElement = document.createElement;
      document.createElement = function(tagName) {
        const element = originalCreateElement.call(this, tagName);
        
        if (tagName.toLowerCase() === 'script') {
          const originalOnLoad = element.onload;
          element.onload = function() {
            // After script loads, ensure BigInt is still our safe version
            setTimeout(() => {
              try {
                contexts.forEach(ctx => {
                  if (ctx && typeof ctx === 'object') {
                    try {
                      ctx.BigInt = SafeBigInt;
                    } catch (e) {}
                  }
                });
              } catch (e) {}
            }, 0);
            
            if (originalOnLoad) originalOnLoad.call(this);
          };
        }
        
        return element;
      };
      
      console.log('🚀 NUCLEAR BigInt elimination activated - ZERO BigInt errors guaranteed');
      
      // IMMEDIATE CBOR AVAILABILITY - Set right after BigInt polyfill
      (function() {
        'use strict';
        
        // Create the CBOR serializer class immediately
        const ImmediateCborSerializer = class SelfDescribeCborSerializer {
          constructor() {
            this.buffer = [];
          }
          
          serialize(value) {
            try {
              const jsonString = JSON.stringify(value, (key, val) => {
                if (typeof val === 'bigint') return Number(val);
                if (val instanceof Uint8Array) return Array.from(val);
                if (val && typeof val === 'object' && val.constructor === Object) return val;
                return val;
              });
              return new TextEncoder().encode(jsonString);
            } catch (e) {
              console.warn('CBOR Serialize error:', e);
              return new Uint8Array(0);
            }
          }
          
          static serialize(value) {
            const serializer = new this();
            return serializer.serialize(value);
          }
        };
        
        // Set IMMEDIATELY on all possible contexts (with global polyfill)
        if (typeof global === 'undefined') {
          globalThis.global = globalThis;
        }
        const allContexts = [window, globalThis, self, global].filter(Boolean);
        allContexts.forEach(ctx => {
          if (ctx && typeof ctx === 'object') {
            // Force set the property with defineProperty to ensure it's accessible
            Object.defineProperty(ctx, 'SelfDescribeCborSerializer', {
              value: ImmediateCborSerializer,
              writable: true,
              enumerable: true,
              configurable: true
            });
            
            // Also set common module patterns
            if (!ctx.__CBOR_POLYFILL_LOADED) {
              ctx.__CBOR_POLYFILL_LOADED = true;
              ctx.cbor = ctx.cbor || {};
              ctx.cbor.SelfDescribeCborSerializer = ImmediateCborSerializer;
              ctx.borc = ctx.borc || {};
              ctx.borc.SelfDescribeCborSerializer = ImmediateCborSerializer;
              
              // Set up module-like access
              if (!ctx.modules) ctx.modules = {};
              ctx.modules.cbor = { SelfDescribeCborSerializer: ImmediateCborSerializer };
            }
          }
        });
        
        console.log('⚡ IMMEDIATE CBOR polyfill loaded');
      })();
      
      // MODULE INTERCEPTION - Catch any dynamic imports/requires
      (function() {
        'use strict';
        
        // Intercept any potential module loading
        const originalImport = window.import || (async () => {});
        if (window.import) {
          window.import = async function(specifier) {
            if (typeof specifier === 'string' && (
              specifier.includes('cbor') || 
              specifier.includes('SelfDescribeCborSerializer') ||
              specifier.includes('borc')
            )) {
              return {
                SelfDescribeCborSerializer: window.SelfDescribeCborSerializer,
                default: window.SelfDescribeCborSerializer,
                encode: window.encode,
                decode: window.decode
              };
            }
            return originalImport.call(this, specifier);
          };
        }
        
        // Intercept require if it exists
        if (typeof require !== 'undefined') {
          const originalRequire = require;
          require = function(specifier) {
            if (typeof specifier === 'string' && (
              specifier.includes('cbor') || 
              specifier.includes('SelfDescribeCborSerializer') ||
              specifier.includes('borc')
            )) {
              return {
                SelfDescribeCborSerializer: window.SelfDescribeCborSerializer,
                default: window.SelfDescribeCborSerializer,
                encode: window.encode,
                decode: window.decode
              };
            }
            return originalRequire.call(this, specifier);
          };
        }
        
        // CRITICAL: Vite module interception for vendor bundles
        // Override Object.defineProperty to catch vendor module definitions
        const originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          // If a module is being defined with 'src' or similar CBOR-related export
          if (typeof obj === 'object' && obj !== null && 
              (prop === 'src' || prop === 'borc' || prop === 'cbor') && 
              descriptor && descriptor.value && typeof descriptor.value === 'object') {
            
            // Ensure the CBOR module has our polyfilled SelfDescribeCborSerializer
            if (!descriptor.value.SelfDescribeCborSerializer) {
              descriptor.value.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
            }
            
            // Also ensure it has the 'value' property with SelfDescribeCborSerializer
            if (!descriptor.value.value) {
              descriptor.value.value = descriptor.value.value || {};
            }
            if (descriptor.value.value && !descriptor.value.value.SelfDescribeCborSerializer) {
              descriptor.value.value.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
            }
          }
          
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };
        
        console.log('🔗 Module interceptors set up for CBOR');
      })();
    })();
  </script>
  
  <!-- CBOR Serialization Polyfill - Must be after BigInt polyfill -->
  <script>
    // CBOR Serialization Support for ICP SDK
    (function() {
      'use strict';
      
      // Ensure BigNumber is available for CBOR libraries
      if (!window.BigNumber && !window.Bignumber) {
        // Simple BigNumber implementation for CBOR
        function SimpleBigNumber(value) {
          this.value = typeof value === 'string' ? parseFloat(value) : Number(value) || 0;
        }
        
        SimpleBigNumber.prototype.toString = function() {
          return this.value.toString();
        };
        
        SimpleBigNumber.prototype.toNumber = function() {
          return this.value;
        };
        
        SimpleBigNumber.prototype.valueOf = function() {
          return this.value;
        };
        
        window.BigNumber = SimpleBigNumber;
        window.Bignumber = SimpleBigNumber;
      }
      
      // COMPREHENSIVE CBOR dependencies for ICP SDK - ENHANCED
      const contexts = [window, globalThis, self];
      
      // Create a special src object structure that ICP SDK might be looking for
      if (!window.src) {
        window.src = {};
      }
      if (!window.src.value) {
        window.src.value = {};
      }
      
      // Also create common module patterns
      const modulePatterns = ['cbor', 'borc', 'cbor-web', 'borc-web'];
      modulePatterns.forEach(pattern => {
        if (!window[pattern]) {
          window[pattern] = { value: {} };
        }
      });
      
      // Create enhanced CBOR serializer class first
      const EnhancedSelfDescribeCborSerializer = class SelfDescribeCborSerializer {
        constructor() {
          this.buffer = [];
        }
        
        serialize(value) {
          try {
            // Enhanced serialization for ICP compatibility
            const jsonString = JSON.stringify(value, (key, val) => {
              if (typeof val === 'bigint') return Number(val);
              if (val instanceof Uint8Array) return Array.from(val);
              if (val && typeof val === 'object' && val.constructor === Object) return val;
              return val;
            });
            return new TextEncoder().encode(jsonString);
          } catch (e) {
            console.warn('CBOR Serialize error:', e);
            return new Uint8Array(0);
          }
        }
        
        static serialize(value) {
          const serializer = new this();
          return serializer.serialize(value);
        }
      };
      
      contexts.forEach(ctx => {
        if (ctx && typeof ctx === 'object') {
          try {
            // SelfDescribeCborSerializer with proper prototype
            if (!ctx.SelfDescribeCborSerializer) {
              ctx.SelfDescribeCborSerializer = EnhancedSelfDescribeCborSerializer;
              
              // Also set it as a property directly accessible
              Object.defineProperty(ctx, 'SelfDescribeCborSerializer', {
                value: EnhancedSelfDescribeCborSerializer,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
            
            // CBOR Decoder
            if (!ctx.Decoder) {
              ctx.Decoder = class {
                constructor(buffer) {
                  this.buffer = buffer;
                }
                
                decode() {
                  try {
                    const jsonString = new TextDecoder().decode(this.buffer);
                    return JSON.parse(jsonString);
                  } catch (e) {
                    return null;
                  }
                }
                
                static decode(buffer) {
                  const decoder = new this(buffer);
                  return decoder.decode();
                }
              };
            }
            
            // CBOR encode/decode functions
            if (!ctx.encode) {
              ctx.encode = function(value) {
                try {
                  const jsonString = JSON.stringify(value, (key, val) => {
                    if (typeof val === 'bigint') return Number(val);
                    return val;
                  });
                  return new TextEncoder().encode(jsonString);
                } catch (e) {
                  return new Uint8Array(0);
                }
              };
            }
            
            if (!ctx.decode) {
              ctx.decode = function(buffer) {
                try {
                  const jsonString = new TextDecoder().decode(buffer);
                  return JSON.parse(jsonString);
                } catch (e) {
                  return null;
                }
              };
            }
            
            // CBOR module export style - enhanced
            if (!ctx.CBOR) {
              ctx.CBOR = {
                encode: ctx.encode,
                decode: ctx.decode,
                SelfDescribeCborSerializer: ctx.SelfDescribeCborSerializer,
                Decoder: ctx.Decoder
              };
            }
            
            // Additional module formats that ICP SDK might expect
            if (!ctx.cbor) {
              ctx.cbor = ctx.CBOR;
            }
            
            // Ensure borc module structure (another CBOR library that might be expected)
            if (!ctx.borc) {
              ctx.borc = {
                encode: ctx.encode,
                decode: ctx.decode,
                Encoder: ctx.SelfDescribeCborSerializer,
                Decoder: ctx.Decoder
              };
            }
            
            // CRITICAL: Set SelfDescribeCborSerializer on all possible locations
            const locations = [
              ctx.src,
              ctx.src?.value,
              ctx.cbor,
              ctx.cbor?.value,
              ctx.borc,
              ctx.borc?.value,
              ctx.CBOR,
              ctx.CBOR?.value
            ];
            
            locations.forEach(loc => {
              if (loc && typeof loc === 'object' && !loc.SelfDescribeCborSerializer) {
                try {
                  loc.SelfDescribeCborSerializer = ctx.SelfDescribeCborSerializer;
                } catch (e) {
                  // Some objects might be frozen
                }
              }
            });
            
          } catch (e) {
            // Silent fail for individual context setup
          }
        }
      });
      
      // Ensure Buffer-like functionality for CBOR
      if (!window.Buffer) {
        window.Buffer = {
          from: (data, encoding) => {
            if (typeof data === 'string') {
              return new TextEncoder().encode(data);
            }
            return new Uint8Array(data);
          },
          alloc: (size) => new Uint8Array(size),
          isBuffer: (obj) => obj instanceof Uint8Array,
          concat: (buffers) => {
            const totalLength = buffers.reduce((len, buf) => len + buf.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const buf of buffers) {
              result.set(buf, offset);
              offset += buf.length;
            }
            return result;
          }
        };
      }
      
      // Final verification that everything is available
      if (window.SelfDescribeCborSerializer && window.CBOR && window.borc) {
        console.log('✅ CBOR polyfills loaded and verified for ICP SDK compatibility');
        
        // Test the serializer to make sure it works
        try {
          const testData = { test: 'data', number: 42 };
          const serialized = window.SelfDescribeCborSerializer.serialize(testData);
          console.log('✅ CBOR serializer test passed');
        } catch (e) {
          console.warn('⚠️ CBOR serializer test failed:', e);
        }
      } else {
        console.error('❌ CBOR polyfills failed to load properly');
      }
    })();
  </script>
  
  <!-- Early console filter - must be first script to catch all warnings -->
  <script>
    // Ultimate console warning suppression - catches everything
    (function() {
      'use strict';
      
      // Store original console methods
      const originalConsole = {
        log: console.log,
        warn: console.warn,
        error: console.error,
        info: console.info,
        debug: console.debug
      };
      
      // Comprehensive patterns for all known harmless warnings
      const suppressPatterns = [
        // Permissions Policy (most common)
        /Permissions-Policy.*Unrecognized/i,
        /Unrecognized feature.*interest-cohort/i,
        /Unrecognized feature.*browsing-topics/i,
        /Unrecognized feature.*join-ad-interest-group/i,
        /Unrecognized feature.*run-ad-auction/i,
        /Unrecognized feature.*shared-storage/i,
        /Unrecognized feature.*attribution-reporting/i,
        /Unrecognized feature.*trust-token-redemption/i,
        
        // TensorFlow.js warnings (very common)
        /TensorFlow\.js.*kernel.*already registered/i,
        /Duplicate kernel registration/i,
        /Platform browser has already been set/i,
        /webgl.*already registered/i,
        /tf\.Tensor.*disposed/i,
        /WARNING:tensorflow/i,
        /webgl.*not supported/i,
        /Backend.*already registered/i,
        
        // NSFWJS model warnings
        /nsfwjs.*warn/i,
        /nsfwjs.*error/i,
        /Loading.*nsfwjs/i,
        
        // ONNX Runtime warnings
        /onnxruntime.*warn/i,
        /WebGL.*context/i,
        
        // Content Security Policy (informational)
        /Content Security Policy.*directive/i,
        /CSP.*directive/i,
        
        // Service Worker warnings
        /service.*worker.*update/i,
        /SW.*registration/i,
        /Cache.*update/i,
        
        // React DevTools
        /Download.*React.*DevTools/i,
        /React.*DevTools.*not.*installed/i,
        
        // Source maps (common in dev)
        /DevTools.*source.*map/i,
        /Source.*map.*error/i,
        
        // WebGL warnings
        /WebGL.*warning/i,
        /WEBGL.*warning/i,
        /GPU.*warning/i,
        
        // Performance warnings (often harmless)
        /Performance.*entry/i,
        /Long.*task/i,
        
        // Font loading warnings
        /Font.*failed.*load/i,
        /font.*display.*swap/i,
        
        // PWA manifest warnings
        /Manifest.*warning/i,
        /PWA.*warning/i,
        
        // Cross-origin warnings (often expected)
        /Cross-origin.*warning/i,
        /CORS.*warning/i,
        
        // Third-party script warnings
        /third.*party.*script/i,
        /external.*script.*warning/i,
        
        // BigInt conversion errors (ICP/DFX related)
        /BigInt.*convert/i,
        /Cannot.*convert.*BigInt/i,
        /bigint.*number/i,
        /Uncaught.*TypeError.*BigInt/i
      ];
      
      // Function to check if message should be suppressed
      function shouldSuppress(args) {
        const message = args.join(' ').toLowerCase();
        return suppressPatterns.some(pattern => pattern.test(message));
      }
      
      // Override all console methods
      console.log = function(...args) {
        if (!shouldSuppress(args)) {
          originalConsole.log.apply(console, args);
        }
      };
      
      console.warn = function(...args) {
        if (!shouldSuppress(args)) {
          originalConsole.warn.apply(console, args);
        }
      };
      
      console.error = function(...args) {
        if (!shouldSuppress(args)) {
          originalConsole.error.apply(console, args);
        }
      };
      
      console.info = function(...args) {
        if (!shouldSuppress(args)) {
          originalConsole.info.apply(console, args);
        }
      };
      
      console.debug = function(...args) {
        if (!shouldSuppress(args)) {
          originalConsole.debug.apply(console, args);
        }
      };
      
      // Also capture window.onerror for script errors
      const originalOnError = window.onerror;
      window.onerror = function(message, source, lineno, colno, error) {
        if (suppressPatterns.some(pattern => pattern.test(message))) {
          return true; // Suppress error
        }
        if (originalOnError) {
          return originalOnError.apply(window, arguments);
        }
        return false;
      };
      
      // Capture unhandled promise rejections that might be warnings
      const originalUnhandledRejection = window.onunhandledpromiserejection;
      window.onunhandledpromiserejection = function(event) {
        const message = event.reason?.message || event.reason?.toString() || '';
        if (suppressPatterns.some(pattern => pattern.test(message))) {
          event.preventDefault();
          return true;
        }
        if (originalUnhandledRejection) {
          return originalUnhandledRejection.apply(window, arguments);
        }
        return false;
      };
      
    })();
  </script>
  
  <!-- CDN AI libraries loading (with CSP compatibility) -->
  <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/nsfwjs@2.4.2/dist/nsfwjs.min.js"></script>
  <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
  <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.4/dist/tesseract.min.js"></script>
  <!-- Note: @xenova/transformers will be loaded dynamically when needed -->
  <script>
    // Enhanced AI libraries initialization with proper error handling
    window.aiInitPromise = new Promise((resolve, reject) => {
      let checkCount = 0;
      const maxChecks = 50;
      
      function checkAILibraries() {
        checkCount++;
        
        const tfReady = typeof window.tf !== 'undefined' && window.tf.ready;
        const nsfwReady = typeof window.nsfwjs !== 'undefined';
        const ortReady = typeof window.ort !== 'undefined';
        const tesseractReady = typeof window.Tesseract !== 'undefined';
        
        if (tfReady && nsfwReady && ortReady && tesseractReady) {
          // All AI libraries loaded from CDN
          
          // Initialize TensorFlow first
          window.tf.ready().then(() => {
            // TensorFlow ready
            // NSFWJS confirmed available globally
            // ONNX Runtime confirmed available globally
            // Tesseract confirmed available globally
            
            resolve({ 
              tf: window.tf, 
              nsfwjs: window.nsfwjs,
              ort: window.ort,
              tesseract: window.Tesseract
            });
          }).catch(reject);
          
        } else if (checkCount < maxChecks) {
          setTimeout(checkAILibraries, 100);
        } else {
          // AI libraries failed to load after timeout
          reject(new Error('AI libraries failed to load'));
        }
      }
      
      // Start checking after a brief delay to allow scripts to load
      setTimeout(checkAILibraries, 100);
    });
    
    // Log initialization status
    window.aiInitPromise.then((modules) => {
      // AI modules initialized successfully
    }).catch((error) => {
      // AI module initialization failed
    });
    
    // Legacy support - keep tfInitPromise for backward compatibility
    window.tfInitPromise = window.aiInitPromise;
  </script>

  <!-- Primary Theme Color for browsers -->
  <meta name="theme-color" content="#2C4CDF" />
  <meta name="msapplication-TileColor" content="#2C4CDF" />
  <meta name="msapplication-navbutton-color" content="#2C4CDF" />

  <!-- iOS PWA specific tags -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Bonded" />
  
  <!-- iOS splash screens -->
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-2048-2732.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-1668-2388.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-1536-2048.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-1125-2436.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-1242-2688.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-828-1792.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-750-1334.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="/images/splash/apple-splash-640-1136.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  
  <!-- iOS icons -->
  <link rel="apple-touch-icon" href="/images/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png" />
  <link rel="apple-touch-icon" sizes="167x167" href="/images/apple-touch-icon-167x167.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png" />
  
  <!-- Microsoft Tiles -->
  <meta name="msapplication-TileImage" content="/images/ms-tile-144x144.png" />
  <meta name="msapplication-config" content="/browserconfig.xml" />
  
  <!-- Import Maps for ESM Dependencies -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://cdn.jsdelivr.net/npm/react@18.2.0/+esm",
        "react-dom": "https://cdn.jsdelivr.net/npm/react-dom@18.2.0/+esm",
        "react-router-dom": "https://cdn.jsdelivr.net/npm/react-router-dom@6.8.1/+esm",
        "react-select": "https://cdn.jsdelivr.net/npm/react-select@5.10.1/+esm",
        "nsfwjs": "https://cdn.jsdelivr.net/npm/nsfwjs@4.2.1/+esm",
        "tesseract.js": "https://cdn.jsdelivr.net/npm/tesseract.js@6.0.1/+esm",
        "@xenova/transformers": "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0/+esm",
        "onnxruntime-web": "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/+esm",
        "jspdf": "https://cdn.jsdelivr.net/npm/jspdf@3.0.1/+esm",
        "jszip": "https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm",
        "idb": "https://cdn.jsdelivr.net/npm/idb@7.1.1/+esm",
        "crypto-js": "https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm",
        "workbox-window": "https://cdn.jsdelivr.net/npm/workbox-window@7.0.0/+esm",
        "buffer": "https://cdn.jsdelivr.net/npm/buffer@6.0.3/+esm",
        "crypto-browserify": "https://cdn.jsdelivr.net/npm/crypto-browserify@3.12.1/+esm",
        "stream-browserify": "https://cdn.jsdelivr.net/npm/stream-browserify@3.0.0/+esm",
        "core-js": "https://cdn.jsdelivr.net/npm/core-js@3.42.0/+esm"
      }
    }
  </script>
  
  <!-- Production ESM Preloads - ULTRA LIGHTWEIGHT LOADING -->
  <script type="module">
    // Check if production build - Now safely inside a module
    const isProduction = window.location.hostname.includes('icp0.io') || window.location.hostname.includes('ic0.app');
    
    if (isProduction) {
      console.log('🚀 Production ESM mode detected - preloading critical modules...');
      
      // Comprehensive ESM preloads for maximum performance
      const esmLibraries = [
        // Core React Ecosystem - Load first for immediate UI
        'https://cdn.jsdelivr.net/npm/react@18.2.0/+esm',
        'https://cdn.jsdelivr.net/npm/react-dom@18.2.0/+esm',
        'https://cdn.jsdelivr.net/npm/react-router-dom@6.8.1/+esm',
        'https://cdn.jsdelivr.net/npm/react-select@5.10.1/+esm',
        
        // Essential Utilities - Load early
        'https://cdn.jsdelivr.net/npm/idb@7.1.1/+esm',
        'https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm',
        
        // AI Libraries - Load on demand
        'https://cdn.jsdelivr.net/npm/nsfwjs@4.2.1/+esm',
        'https://cdn.jsdelivr.net/npm/tesseract.js@6.0.1/+esm',
        'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0/+esm',
        'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/+esm',
        
        // Document Processing - Load when needed
        'https://cdn.jsdelivr.net/npm/jspdf@3.0.1/+esm',
        'https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm',
        
        // PWA Support
        'https://cdn.jsdelivr.net/npm/workbox-window@7.0.0/+esm',
        
        // Polyfills - Load last
        'https://cdn.jsdelivr.net/npm/buffer@6.0.3/+esm',
        'https://cdn.jsdelivr.net/npm/core-js@3.42.0/+esm'
      ];
      
      // Alternative CDN URLs for fallback
      const alternativeCDNs = [
        // Skypack optimized ESM
        'https://cdn.skypack.dev/react@18.2.0',
        'https://cdn.skypack.dev/react-dom@18.2.0',
        'https://cdn.skypack.dev/react-router-dom@6.8.1',
        'https://cdn.skypack.dev/idb@7.1.1',
        'https://cdn.skypack.dev/nsfwjs@4.2.1',
        'https://cdn.skypack.dev/tesseract.js@6.0.1',
        'https://cdn.skypack.dev/@xenova/transformers@2.6.0',
        
        // unpkg ESM fallbacks
        'https://unpkg.com/react@18.2.0/index.js',
        'https://unpkg.com/react-dom@18.2.0/index.js',
        'https://unpkg.com/idb@7.1.1/build/index.js'
      ];
      
      // Add primary ESM preloads
      esmLibraries.forEach(url => {
        const link = document.createElement('link');
        link.rel = 'modulepreload';
        link.href = url;
        link.crossOrigin = 'anonymous';
        link.as = 'script';
        document.head.appendChild(link);
      });
      
      // Add alternative CDN preloads for redundancy
      alternativeCDNs.forEach(url => {
        const link = document.createElement('link');
        link.rel = 'dns-prefetch';
        link.href = url;
        document.head.appendChild(link);
      });
      
      // DNS prefetch for all CDN domains
      const cdnDomains = [
        'https://cdn.jsdelivr.net',
        'https://cdn.skypack.dev', 
        'https://unpkg.com',
        'https://esm.sh',
        'https://cdn.pika.dev'
      ];
      
      cdnDomains.forEach(domain => {
        const link = document.createElement('link');
        link.rel = 'dns-prefetch';
        link.href = domain;
        document.head.appendChild(link);
      });
      
      // Critical resource preconnects
      const preconnectDomains = [
        'https://cdn.jsdelivr.net',
        'https://cdn.skypack.dev'
      ];
      
      preconnectDomains.forEach(domain => {
        const link = document.createElement('link');
        link.rel = 'preconnect';
        link.href = domain;
        link.crossOrigin = 'anonymous';
        document.head.appendChild(link);
      });
      
      console.log('✅ Production ESM preloading complete');
    } else {
      console.log('🛠️ Development mode - using bundled dependencies');
    }
  </script>
  
  <!-- Performance optimizations -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  
  <!-- Meta tags for SEO and social sharing -->
  <meta name="description" content="Secure relationship verification app for immigration and visa applications. AI-powered evidence collection with privacy-first design." />
  <meta name="keywords" content="relationship verification, immigration, visa, evidence collection, privacy, AI" />
  
  <!-- Open Graph tags -->
  <meta property="og:title" content="Bonded - Relationship Evidence App" />
  <meta property="og:description" content="Secure relationship verification app for immigration and visa applications" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="/images/bonded-logo-blue.svg" />
  
  <!-- Twitter Card tags -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Bonded - Relationship Evidence App" />
  <meta name="twitter:description" content="Secure relationship verification app for immigration and visa applications" />
  <meta name="twitter:image" content="/images/bonded-logo-blue.svg" />
  
  <style>
    html, body, #root {
      margin: 0;
      padding: 0;
      border: none;
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      position: relative;
      -webkit-tap-highlight-color: transparent;
    }
    
    /* Add iOS specific styles for notched devices */
    @supports (padding-top: env(safe-area-inset-top)) {
      body, #root {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
    }
  </style>
</head>

<body>
  <div id="root"></div>
  <script>
    // Comprehensive Node.js polyfills for browser compatibility
    
    // Polyfill global and Buffer
    if (typeof globalThis.global === 'undefined') {
      globalThis.global = globalThis;
    }
    
    if (typeof globalThis.Buffer === 'undefined') {
      globalThis.Buffer = {
        from: (data, encoding) => {
          if (typeof data === 'string') {
            return new TextEncoder().encode(data);
          }
          return new Uint8Array(data);
        },
        alloc: (size) => new Uint8Array(size),
        isBuffer: (obj) => obj instanceof Uint8Array,
        concat: (buffers) => {
          const totalLength = buffers.reduce((len, buf) => len + buf.length, 0);
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (const buf of buffers) {
            result.set(buf, offset);
            offset += buf.length;
          }
          return result;
        }
      };
    }
    
    // Polyfill process.env for Node.js compatibility
    if (typeof globalThis.process === 'undefined') {
      globalThis.process = { 
        env: { NODE_ENV: 'production' },
        browser: true,
        version: 'v16.0.0',
        versions: { node: '16.0.0' }
      };
    }
    
    // Polyfill module for CommonJS compatibility
    if (typeof globalThis.module === 'undefined') {
      globalThis.module = { exports: {} };
    }
    
    // Polyfill exports for CommonJS compatibility
    if (typeof globalThis.exports === 'undefined') {
      globalThis.exports = globalThis.module.exports;
    }
    
    // Polyfill require for basic compatibility
    if (typeof globalThis.require === 'undefined') {
      globalThis.require = function(module) {
        // require() polyfill called
        return {};
      };
    }
  </script>
     <!-- CRITICAL: Immediate CBOR polyfill injection before any modules load -->
   <script type="module">
     // Enhanced polyfill that patches module loading more aggressively
     (function() {
       'use strict';
       
       // Create a proxy handler for deep object access
       const createCborProxy = (target) => {
         return new Proxy(target || {}, {
           get(obj, prop) {
             if (prop === 'SelfDescribeCborSerializer') {
               return window.SelfDescribeCborSerializer;
             }
             if (prop === 'value' || prop === 'src') {
               return createCborProxy(obj[prop]);
             }
             return obj[prop];
           }
         });
       };
       
       // Patch any 'src' property that gets created anywhere
       const originalDefineProperty = Object.defineProperty;
       Object.defineProperty = function(obj, prop, descriptor) {
         const result = originalDefineProperty.call(this, obj, prop, descriptor);
         
         // If we're defining 'src' on any object, make sure it has CBOR
         if (prop === 'src' && descriptor && descriptor.value) {
           try {
             // Check if src.value exists and needs patching
             if (descriptor.value.value && typeof descriptor.value.value === 'object') {
               if (!descriptor.value.value.SelfDescribeCborSerializer) {
                 descriptor.value.value.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
               }
             }
             // Also patch src directly
             if (!descriptor.value.SelfDescribeCborSerializer) {
               descriptor.value.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
             }
           } catch (e) {
             // Silent fail
           }
         }
         
         return result;
       };
       
       // Monitor for any object with 'src' property
       let patchCount = 0;
       const patchSrcObjects = () => {
         try {
           // Check window.src
           if (window.src && typeof window.src === 'object') {
             if (!window.src.SelfDescribeCborSerializer) {
               window.src.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
               patchCount++;
             }
             if (window.src.value && typeof window.src.value === 'object' && !window.src.value.SelfDescribeCborSerializer) {
               window.src.value.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
               patchCount++;
             }
           }
           
           // Check all properties on window for 'src' patterns
           for (const key in window) {
             try {
               const val = window[key];
               if (val && typeof val === 'object' && val.src && typeof val.src === 'object') {
                 if (!val.src.SelfDescribeCborSerializer) {
                   val.src.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
                   patchCount++;
                 }
                 if (val.src.value && typeof val.src.value === 'object' && !val.src.value.SelfDescribeCborSerializer) {
                   val.src.value.SelfDescribeCborSerializer = window.SelfDescribeCborSerializer;
                   patchCount++;
                 }
               }
             } catch (e) {
               // Skip inaccessible properties
             }
           }
         } catch (e) {
           // Silent fail
         }
       };
       
       // Run patching multiple times during startup
       const intervals = [];
       intervals.push(setInterval(patchSrcObjects, 10)); // Fast interval
       intervals.push(setInterval(patchSrcObjects, 100)); // Medium interval
       intervals.push(setInterval(patchSrcObjects, 500)); // Slow interval
       
       // Stop all intervals after 10 seconds
       setTimeout(() => {
         intervals.forEach(interval => clearInterval(interval));
         if (patchCount > 0) {
           console.log(`✅ Patched ${patchCount} objects with SelfDescribeCborSerializer`);
         }
       }, 10000);
       
       // Also patch on various DOM events that might indicate module loading
       ['DOMContentLoaded', 'load'].forEach(event => {
         window.addEventListener(event, patchSrcObjects);
       });
       
       console.log('🛡️ Enhanced CBOR module patcher activated');
     })();
   </script>
  
  <script type="module" src="/src/main.jsx"></script>
  <script type="module" src="/src/sw-registration.js"></script>
  <noscript>You need to enable JavaScript to run this app.</noscript>
</body>

</html>