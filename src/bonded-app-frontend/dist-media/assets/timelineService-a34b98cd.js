var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});import{_ as __vitePreload}from"./icp-sdk-b71c0736.js";import"./encryption-3413e488.js";import{icpCanisterService}from"./icpCanisterService-30902200.js";import{o as openDB}from"./vendor-e6e658b6.js";import"./index-ed0f0e28.js";const _TimelineService=class _TimelineService{constructor(){this.db=null,this.cachedTimeline=[],this.lastFetchTime=null,this.filters={dateRange:{start:null,end:null},contentType:"all",uploadStatus:"all",partner:"all"},this.initDB()}async initDB(){try{this.db=await openDB("BondedTimelineDB",1,{upgrade(db){if(!db.objectStoreNames.contains("timelineCache")){const store=db.createObjectStore("timelineCache");store.createIndex("timestamp","timestamp"),store.createIndex("date","date"),store.createIndex("type","type")}db.objectStoreNames.contains("exportHistory")||db.createObjectStore("exportHistory",{autoIncrement:!0}).createIndex("timestamp","timestamp")}})}catch{}}async fetchTimeline(options={}){try{const{page=1,limit=50,forceRefresh=!1}=options;if(!forceRefresh&&this.cachedTimeline.length>0&&this.lastFetchTime&&Date.now()-this.lastFetchTime<5*60*1e3)return this.applyFilters(this.cachedTimeline);const relationshipId="mock-relationship-id",timelineData=await icpCanisterService.fetchTimeline({relationshipId,page,limit}),decryptedTimeline=await this.decryptTimelineItems(timelineData);return this.cachedTimeline=decryptedTimeline,this.lastFetchTime=Date.now(),this.applyFilters(decryptedTimeline)}catch(error){throw error}}async decryptTimelineItems(encryptedItems){const decryptedItems=[];for(const item of encryptedItems)try{if(item.encrypted){const decryptedContent=await this.decryptItem(item);decryptedItems.push({...item,decrypted:!0,content:decryptedContent,displayData:this.prepareDisplayData(decryptedContent,item.metadata)})}else decryptedItems.push({...item,decrypted:!1,content:item.content||{},displayData:this.prepareDisplayData(item.content||{},item.metadata)})}catch(error){decryptedItems.push({...item,decrypted:!1,error:error.message,displayData:{title:"Decryption Failed",subtitle:`Error: ${error.message}`,preview:"Unable to decrypt this evidence item",type:"error"}})}return decryptedItems}async decryptItem(item){try{const{encryptionService}=await __vitePreload(()=>import("./index-556a343f.js"),["assets/index-556a343f.js","assets/icp-sdk-b71c0736.js","assets/vendor-e6e658b6.js","assets/evidenceFilter-6e1ec898.js","assets/textClassification-848edeeb.js","assets/encryption-3413e488.js","assets/canisterIntegration-a5c53e9e.js","assets/index-ed0f0e28.js","assets/icpNetworkHelper-2c245b46.js","assets/emailService-11bba984.js","assets/mediaAccess-9b6d075b.js","assets/icpCanisterService-30902200.js"]),testKey=await encryptionService.generateMasterKey();if(item.encryptedData)try{return await encryptionService.decryptEvidencePackage(item.encryptedData,testKey)}catch{return await this.simulateDecryption(item)}else return await this.simulateDecryption(item)}catch{return await this.simulateDecryption(item)}}async simulateDecryption(item){await new Promise(resolve=>setTimeout(resolve,100));const content={targetDate:item.metadata.originalDate,packageTime:item.timestamp,metadata:{packageId:item.id,deviceInfo:{userAgent:"Mock User Agent",timestamp:item.timestamp}}};if(item.metadata.hasPhoto&&(content.photo={name:`photo-${item.metadata.originalDate}.jpg`,type:"image/jpeg",size:1024*1024,mockPhotoUrl:"/images/mock-couple-photo.jpg"},content.metadata.photoMetadata={originalDate:item.metadata.originalDate,location:"London, UK",source:"device_camera"}),item.metadata.messageCount>0){content.messages=[];for(let i=0;i<item.metadata.messageCount;i++)content.messages.push(`Mock message ${i+1} from ${item.metadata.originalDate}`);content.metadata.messagesMetadata={totalFound:item.metadata.messageCount,selected:item.metadata.messageCount,source:"telegram"}}return content}prepareDisplayData(content,metadata){const displayData={type:"evidence",date:content.targetDate||metadata.originalDate,title:"",subtitle:"",preview:"",thumbnail:null,hasPhoto:!!content.photo,messageCount:content.messages?content.messages.length:0};content.photo&&content.messages&&content.messages.length>0?(displayData.title=`Photo + ${content.messages.length} Messages`,displayData.type="photo_messages"):content.photo?(displayData.title="Photo",displayData.type="photo"):content.messages&&content.messages.length>0?(displayData.title=`${content.messages.length} Messages`,displayData.type="messages"):displayData.title="Evidence Package";const date=new Date(content.targetDate||metadata.originalDate);if(displayData.subtitle=date.toLocaleDateString("en-GB",{weekday:"long",year:"numeric",month:"long",day:"numeric"}),content.metadata?.photoMetadata?.location&&(displayData.subtitle+=` â€¢ ${content.metadata.photoMetadata.location}`),content.messages&&content.messages.length>0){const firstMessage=content.messages[0];displayData.preview=firstMessage.length>100?firstMessage.substring(0,100)+"...":firstMessage}else content.photo?displayData.preview="Photo evidence":displayData.preview="Evidence package";return content.photo&&content.photo.mockPhotoUrl&&(displayData.thumbnail=content.photo.mockPhotoUrl),displayData}applyFilters(items){let filtered=[...items];return(this.filters.dateRange.start||this.filters.dateRange.end)&&(filtered=filtered.filter(item=>{const itemDate=new Date(item.displayData.date);return!(this.filters.dateRange.start&&itemDate<this.filters.dateRange.start||this.filters.dateRange.end&&itemDate>this.filters.dateRange.end)})),this.filters.contentType!=="all"&&(filtered=filtered.filter(item=>{switch(this.filters.contentType){case"photos":return item.displayData.hasPhoto;case"messages":return item.displayData.messageCount>0&&!item.displayData.hasPhoto;case"documents":return item.displayData.type==="document";default:return!0}})),this.filters.uploadStatus!=="all"&&(filtered=filtered.filter(item=>item.uploadStatus===this.filters.uploadStatus)),this.filters.partner!=="all"&&(filtered=filtered.filter(item=>item.uploader===this.filters.partner)),filtered.sort((a,b)=>{const dateA=new Date(a.displayData.date);return new Date(b.displayData.date)-dateA}),filtered}updateFilters(newFilters){this.filters={...this.filters,...newFilters}}getFilters(){return{...this.filters}}async exportToPDF(selectedItems,options={}){try{const{title="Relationship Evidence",includeMetadata=!0,includeImages=!0,pageSize="a4"}=options;return null}catch(error){throw error}}getStatistics(){const stats={totalItems:this.cachedTimeline.length,photoItems:0,messageItems:0,uploadedItems:0,pendingItems:0,failedItems:0,dateRange:{earliest:null,latest:null}};for(const item of this.cachedTimeline){switch(item.displayData.hasPhoto&&stats.photoItems++,item.displayData.messageCount>0&&stats.messageItems++,item.uploadStatus){case"uploaded":stats.uploadedItems++;break;case"pending":stats.pendingItems++;break;case"failed":stats.failedItems++;break}const itemDate=new Date(item.displayData.date);(!stats.dateRange.earliest||itemDate<stats.dateRange.earliest)&&(stats.dateRange.earliest=itemDate),(!stats.dateRange.latest||itemDate>stats.dateRange.latest)&&(stats.dateRange.latest=itemDate)}return stats}async logExport(exportData){if(this.db)try{await this.db.add("exportHistory",exportData)}catch{}}async clearCache(){if(this.cachedTimeline=[],this.lastFetchTime=null,this.db)try{await this.db.clear("timelineCache")}catch{}}async cleanup(){try{await this.clearCache(),this.db&&(this.db.close(),this.db=null)}catch{}}async addTimelineEntry(evidenceEntry){try{const entryDate=new Date(evidenceEntry.timestamp).toISOString().split("T")[0];if(evidenceEntry.date=entryDate,evidenceEntry.uploadStatus=evidenceEntry.uploadStatus||"pending",this.cachedTimeline.unshift(evidenceEntry),this.db)try{await this.db.put("timelineCache",evidenceEntry,evidenceEntry.id)}catch{}return evidenceEntry.uploadStatus="pending",evidenceEntry}catch(error){throw new Error(`Failed to add timeline entry: ${error.message}`)}}async getClusteredTimeline(){try{let timeline=await this.fetchTimeline();if(Array.isArray(timeline)||(timeline=[]),timeline.length===0)return[];const clusteredEntries={};for(const entry of timeline){if(!entry||typeof entry!="object")continue;let entryDate;try{entryDate=entry.date||new Date(entry.timestamp).toISOString().split("T")[0]}catch{continue}clusteredEntries[entryDate]||(clusteredEntries[entryDate]={date:entryDate,entries:[],totalItems:0,photoCount:0,messageCount:0,textCount:0}),clusteredEntries[entryDate].entries.push(entry),clusteredEntries[entryDate].totalItems++;const entryType=entry.type||"unknown",entryContent=entry.content||{};(entryType==="photo"||entryContent.file||entryContent.photo)&&clusteredEntries[entryDate].photoCount++,(entryType==="message"||entryContent.messages||Array.isArray(entryContent.messages)&&entryContent.messages.length>0)&&clusteredEntries[entryDate].messageCount++,(entryType==="text"||entryContent.text)&&clusteredEntries[entryDate].textCount++}return Object.values(clusteredEntries).sort((a,b)=>new Date(b.date)-new Date(a.date))}catch{return[]}}async loadFromLocalStorage(){if(!this.db)return[];try{return(await this.db.transaction("timelineCache","readonly").objectStore("timelineCache").getAll()).sort((a,b)=>new Date(b.timestamp)-new Date(a.timestamp))}catch{return[]}}async getPendingUploads(){try{return(await this.loadFromLocalStorage()).filter(entry=>entry.uploadStatus==="pending")}catch{return[]}}async markAsUploaded(entryIds){try{for(const entryId of entryIds){const cacheIndex=this.cachedTimeline.findIndex(entry=>entry.id===entryId);if(cacheIndex!==-1&&(this.cachedTimeline[cacheIndex].uploadStatus="uploaded",this.cachedTimeline[cacheIndex].uploadedAt=new Date().toISOString()),this.db)try{const entry=await this.db.get("timelineCache",entryId);entry&&(entry.uploadStatus="uploaded",entry.uploadedAt=new Date().toISOString(),await this.db.put("timelineCache",entry,entryId))}catch{}}}catch(error){throw new Error(`Failed to mark entries as uploaded: ${error.message}`)}}async uploadPendingEntries(){try{const pendingEntries=await this.getPendingUploads();if(pendingEntries.length===0)return{success:!0,uploaded:0,failed:0};const uploadResults={success:0,failed:0,errors:[]},relationshipId="mock-relationship-id";for(const entry of pendingEntries)try{await icpCanisterService.uploadEvidence({relationshipId,evidenceData:entry,encrypt:!0}),await this.markAsUploaded([entry.id]),uploadResults.success++}catch(uploadError){uploadResults.failed++,uploadResults.errors.push({entryId:entry.id,error:uploadError.message}),entry.uploadStatus="failed",entry.uploadError=uploadError.message}return{success:uploadResults.success>0,uploaded:uploadResults.success,failed:uploadResults.failed,errors:uploadResults.errors}}catch(error){throw new Error(`Failed to upload pending entries: ${error.message}`)}}};__name(_TimelineService,"TimelineService");let TimelineService=_TimelineService;const timelineService=new TimelineService;export{TimelineService,timelineService};
